<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Primary Meta Tags -->
    <title>Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions</title>
    <meta name="title" content="Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions">
    <meta name="description" content="Free online ballistic calculator for Arma Reforger. Calculate precise firing missions with grid coordinates, elevation, azimuth, fire for effect and time of flight. Supports US M252 81mm and Soviet 2B14 82mm mortars in the moment.">
    <meta name="keywords" content="arma reforger, mortar calculator, firing missons, ballistics, grid coordinates, artillery calculator, mil system, US mortar, Russian mortar, game tool">
    <meta name="author" content="ArmaMortars.org">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://armamortars.org/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://armamortars.org/">
    <meta property="og:title" content="Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions">
    <meta property="og:description" content="Free online mortar calculator for Arma Reforger. Calculate precise firing missions with grid coordinates, elevation, azimuth, fire for effect and time of flight.">
    <meta property="og:image" content="https://armamortars.org/icon.png">
    <meta property="og:site_name" content="ArmaMortars.org">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://armamortars.org/">
    <meta name="twitter:title" content="Arma Reforger Ballistic Calculator">
    <meta name="twitter:description" content="Free online ballistic calculator for Arma Reforger. Calculate precise mortar firing missons in Arma Reforger with grid coordinates.">
    <meta name="twitter:image" content="https://armamortars.org/icon.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#6b8e23">
    
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Arma Reforger Ballistic Calculator",
      "url": "https://armamortars.org/",
      "description": "Calculate precise firing missons for Arma Reforger Mortar Weapon Systems with grid coordinates, elevation, ballistics data, fire corrections and fire for effect patterns.",
      "applicationCategory": "GameApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "150"
      }
    }
    </script>
    
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1f1e 0%, #2a3532 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #6b8e23;
        }
        .logo {
            width: 80px;
            height: auto;
            filter: brightness(0) invert(1) drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }
        h1 {
            color: #c8d4a0;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 1.8em;
            text-align: center;
        }
        h2 {
            color: #b8c7a0;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 25px;
            margin-bottom: 15px;
            border-left: 4px solid #6b8e23;
            padding-left: 12px;
        }
        .container {
            background: rgba(35, 45, 42, 0.85);
            padding: 25px;
            border-radius: 4px;
            border: 1px solid #3a4a45;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            color: #b8c7a0;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #4a5a52;
            border-radius: 2px;
            font-size: 14px;
            background: #2a3532;
            color: #e8e8e8;
            transition: border-color 0.2s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #6b8e23;
            background: #323e3a;
        }
        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        button {
            background: linear-gradient(180deg, #7a9f35 0%, #6b8e23 100%);
            color: white;
            padding: 14px 30px;
            border: 1px solid #5a7e1f;
            border-radius: 2px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        button:hover {
            background: linear-gradient(180deg, #8ab040 0%, #7a9f35 100%);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        button:active {
            transform: translateY(1px);
        }
        button:disabled {
            background: #4a5550;
            border-color: #3a4540;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .btn-press {
            transition: all 0.15s ease;
        }
        .btn-press:active {
            transform: scale(0.95);
            box-shadow: 0 0 20px rgba(143, 188, 30, 0.8);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        .result {
            background: rgba(35, 45, 42, 0.9);
            padding: 20px;
            margin-top: 20px;
            border-radius: 4px;
            display: none;
            border: 1px solid #3a4a45;
        }
        .result.active {
            display: block;
        }
        .result.success {
            background: rgba(35, 45, 42, 0.85);
            border: 2px solid #6b8e23;
        }
        .result.error {
            background: rgba(35, 45, 42, 0.85);
            border: 2px solid #a85050;
        }
        .result h2 {
            margin-top: 0;
            color: #d8e4b0;
        }
        .solution-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        .solution-item {
            background: rgba(20, 25, 22, 0.8);
            padding: 14px;
            border-radius: 2px;
            border: 1px solid #4a5a52;
        }
        .solution-item strong {
            display: block;
            color: #a8b898;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .solution-item .value {
            font-size: 22px;
            color: #e8f4d0;
            font-weight: bold;
        }
        .info {
            background: rgba(60, 80, 95, 0.3);
            border: 1px solid #4a6a75;
            padding: 12px;
            border-radius: 2px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #b8c8d0;
        }
        #loading {
            text-align: center;
            padding: 40px 20px;
            color: #95a585;
            font-size: 16px;
        }
        .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(107, 142, 35, 0.1);
            border-radius: 8px;
        }
        .toggle-buttons {
            display: flex;
            gap: 10px;
        }
        .toggle-option {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 14px;
            flex: 1;
            text-align: center;
            white-space: nowrap;
        }
        .toggle-option.active {
            background: #6b8e23;
            border-color: #8fbc1e;
            box-shadow: 0 2px 8px rgba(107, 142, 35, 0.4);
        }
        .toggle-option:hover:not(.active) {
            background: rgba(255, 255, 255, 0.15);
        }
        .coord-mode {
            display: none;
        }
        .coord-mode.active {
            display: block;
        }
        .history-panel {
            background: rgba(35, 45, 42, 0.85);
            padding: 20px;
            border-radius: 4px;
            border: 1px solid #3a4a45;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .history-item {
            background: rgba(20, 25, 22, 0.8);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 2px;
            border: 1px solid #4a5a52;
            cursor: pointer;
            transition: all 0.2s;
        }
        .history-item:hover {
            background: rgba(30, 35, 32, 0.9);
            border-color: #6b8e23;
        }
        .history-item.active {
            border: 2px solid #6b8e23;
            background: rgba(40, 55, 45, 0.9);
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .history-title {
            color: #c8d4a0;
            font-weight: 600;
            font-size: 13px;
        }
        .history-time {
            color: #95a585;
            font-size: 11px;
        }
        .history-details {
            color: #b8c8d0;
            font-size: 12px;
            margin-top: 5px;
        }
        .history-delete {
            background: transparent;
            border: none;
            color: #a85050;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 16px;
            margin: 0;
            width: auto;
            transition: all 0.2s;
        }
        .history-delete:hover {
            color: #ff6b6b;
            transform: scale(1.2);
        }
        .clear-history-btn {
            background: linear-gradient(180deg, #a85050 0%, #984040 100%);
            border-color: #883030;
            padding: 8px 16px;
            font-size: 12px;
            margin-top: 10px;
        }
        @media (max-width: 600px) {
            .row {
                grid-template-columns: 1fr;
            }
            .solution-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Main Header -->
    <header class="header">
        <img src="https://vectorseek.com/wp-content/uploads/2023/07/Arma-Reforger-Logo-Vector.svg-.png" alt="Arma Reforger Logo - Mortar Calculator" class="logo">
        <h1>ARMA REFORGER Ballistic Mission Planner</h1>
    </header>
    
    <!-- Main Content -->
    <main>
    <div id="loading" role="status" aria-live="polite">Loading ballistic data...</div>
    
    <div id="app" style="display: none;">
        <div class="info">
            ‚ÑπÔ∏è Enter weapon system and target coordinates to calculate firing mission. Mortar charge is automatically selected for optimal range.
        </div>
        
        <!-- History Panel -->
        <div id="historyPanel" class="history-panel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;">üìú Mission History</h2>
                <button class="clear-history-btn" onclick="clearHistory()">Clear All</button>
            </div>
            <div id="historyList"></div>
        </div>
        
        <div class="toggle-container">
            <span style="font-weight: 500; color: #b8c7a0; text-align: center;">Coordinate Input:</span>
            <div class="toggle-buttons">
                <div class="toggle-option active" onclick="setCoordMode('grid')" id="toggleGrid">
                    üéØ Grid (047/069)
                </div>
                <div class="toggle-option" onclick="setCoordMode('meters')" id="toggleMeters">
                    üìè Meters (X/Y)
                </div>
            </div>
        </div>
        
        <div class="container">
            <h2>1Ô∏è‚É£ Weapon System and Ammunition</h2>
            
            <div class="row">
                <div class="form-group">
                    <label for="mortarType">Weapon System Type</label>
                    <select id="mortarType">
                        <!-- Populated dynamically from ballistic-data.json -->
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="shellType">Ammunition Type</label>
                    <select id="shellType">
                        <!-- Populated dynamically from ballistic-data.json -->
                    </select>
                </div>
            </div>
            
            <h2>2Ô∏è‚É£ Weapon Position</h2>
                
                <!-- Grid Mode -->
                <div id="mortarGridMode" class="coord-mode active">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="mortarGridX">Grid X Coordinate</label>
                                <input type="text" id="mortarGridX" placeholder="047 or 0475" style="font-family: monospace; font-size: 16px;">
                            </div>
                            <div class="form-group">
                                <label for="mortarGridY">Grid Y Coordinate</label>
                                <input type="text" id="mortarGridY" placeholder="069 or 0695" style="font-family: monospace; font-size: 16px;">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">3-digit (10m squares) or 4-digit (1m precision)</small>
                    </div>
                </div>
                
                <!-- Meters Mode -->
                <div id="mortarMetersMode" class="coord-mode">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="mortarX">X Coordinate (meters)</label>
                                <input type="number" id="mortarX" placeholder="4800" step="0.1">
                            </div>
                            <div class="form-group">
                                <label for="mortarY">Y Coordinate (meters)</label>
                                <input type="number" id="mortarY" placeholder="7049" step="0.1">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">Enter map coordinates in meters</small>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="mortarZ">Height (m ASL)</label>
                    <input type="number" id="mortarZ" placeholder="168" step="0.1">
                </div>
                
                <h2>Target Position</h2>
                
                <!-- Grid Mode -->
                <div id="targetGridMode" class="coord-mode active">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="targetGridX">Grid X Coordinate</label>
                                <input type="text" id="targetGridX" placeholder="085 or 0850" style="font-family: monospace; font-size: 16px;">
                            </div>
                            <div class="form-group">
                                <label for="targetGridY">Grid Y Coordinate</label>
                                <input type="text" id="targetGridY" placeholder="105 or 1050" style="font-family: monospace; font-size: 16px;">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">3-digit (10m squares) or 4-digit (1m precision)</small>
                    </div>
                </div>
                
                <!-- Meters Mode -->
                <div id="targetMetersMode" class="coord-mode">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="targetX">X Coordinate (meters)</label>
                                <input type="number" id="targetX" placeholder="4696" step="0.1">
                            </div>
                            <div class="form-group">
                                <label for="targetY">Y Coordinate (meters)</label>
                                <input type="number" id="targetY" placeholder="5516" step="0.1">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">Enter map coordinates in meters</small>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="targetZ">Height (m ASL)</label>
                    <input type="number" id="targetZ" placeholder="64" step="0.1">
                </div>
                
                <div class="info" style="margin-top: 15px;">
                    üìç Range, Azimuth, and Height Difference will be computed automatically from coordinates
                </div>
            
            <h2>3Ô∏è‚É£ Fire for Effect (Optional)</h2>
            
            <div class="info" style="margin-bottom: 15px;">
                üéØ Engage area targets with multiple rounds. <strong>Lateral sheaf</strong> for width coverage, <strong>linear sheaf</strong> for depth penetration, <strong>circular pattern</strong> for 360¬∞ area saturation. <strong>Uses corrected target coordinates if applied.</strong>
            </div>
            
            <div class="row">
                <div class="form-group">
                    <label for="ffeEnabled">
                        <input type="checkbox" id="ffeEnabled" style="margin-right: 8px; width: auto; height: auto;">
                        Enable Fire for Effect
                    </label>
                </div>
            </div>
            
            <div id="ffeControls" style="display: none;">
                <div class="row">
                    <div class="form-group">
                        <label for="ffePattern">Sheaf Type</label>
                        <select id="ffePattern">
                            <option value="perpendicular">Lateral Sheaf (Width Coverage)</option>
                            <option value="along-bearing">Linear Sheaf (Depth Penetration)</option>
                            <option value="circular">Circular Pattern (Area Saturation)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="ffeRounds">Rounds per Salvo</label>
                        <select id="ffeRounds">
                            <option value="3">3 Rounds</option>
                            <option value="5" selected>5 Rounds</option>
                            <option value="6">6 Rounds</option>
                            <option value="8">8 Rounds</option>
                            <option value="9">9 Rounds</option>
                            <option value="12">12 Rounds</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group" id="ffeSpacingGroup">
                    <label for="ffeSpacing">Round Interval (meters)</label>
                    <input type="number" id="ffeSpacing" placeholder="50" value="50" min="10" max="200" step="10">
                    <small style="color: #999; display: block; margin-top: 5px;">Spacing between rounds (10-200m)</small>
                </div>
                
                <div class="form-group" id="ffeRadiusGroup" style="display: none;">
                    <label for="ffeRadius">Circle Radius (meters)</label>
                    <input type="number" id="ffeRadius" placeholder="100" value="100" min="20" max="300" step="10">
                    <small style="color: #999; display: block; margin-top: 5px;">Distance from center to impact points (20-300m)</small>
                </div>
            </div>
            
            <div class="form-group">
                <label for="missionLabel">Mission Label (Optional)</label>
                <input type="text" id="missionLabel" placeholder="e.g., TRP 1, TGT AA1234, HILL 201" maxlength="20">
                <small style="color: #999; display: block; margin-top: 5px;">NATO-style identifier: Target Reference Point, Grid, or Designation</small>
            </div>
            
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="calculate" class="btn-press" style="flex: 3;">Compute Fire Mission</button>
                <button id="reset" class="btn-press" style="flex: 1; background: linear-gradient(180deg, #666 0%, #555 100%);">Reset</button>
            </div>
        </div>
        
        <div id="output" class="result"></div>
    </div>
    </main>
    
    <!-- Footer -->
    <footer style="text-align: center; padding: 20px; margin-top: 40px; color: #95a585; font-size: 12px; border-top: 1px solid #3a4a45;">
        <p>¬© 2025 ArmaMortars.org | Free Arma Reforger Mortar Calculator <span style="color: #6b7a65;">v1.5.3</span></p>
        <p>Accurate ballistic calculations for US M252 81mm and Soviet 2B14 82mm | Grid coordinate support</p>
        <p>
            <a href="https://github.com/GeNeFRAG/ArmaReforger/tree/main/mortar_core/" target="_blank" rel="noopener noreferrer" style="color: #8fbc1e; text-decoration: none;">‚≠ê View on GitHub</a>
            | 
            <a href="https://github.com/GeNeFRAG/ArmaReforger/blob/main/LICENSE" target="_blank" rel="noopener noreferrer" style="color: #8fbc1e; text-decoration: none;">üìÑ MIT License</a>
        </p>
    </footer>
    
    <script src="MortarCalculator.js?v=1.5.3"></script>
    <script>
        let ballisticDataLoaded = false;
        
        // Input field ID constants
        const INPUT_IDS = {
            MORTAR_FIELDS: ['mortarGridX', 'mortarGridY', 'mortarX', 'mortarY', 'mortarZ'],
            TARGET_FIELDS: ['targetGridX', 'targetGridY', 'targetX', 'targetY'],
            ALL_COORD_FIELDS: ['mortarGridX', 'mortarGridY', 'mortarX', 'mortarY', 'mortarZ',
                              'targetGridX', 'targetGridY', 'targetX', 'targetY', 'targetZ', 'missionLabel']
        };
        
        // Color constants
        const COLORS = {
            success: '#6b8e23',
            successBg: 'rgba(107, 142, 35, 0.15)',
            successBorder: 'rgba(107, 142, 35, 0.4)',
            successShadow: 'rgba(107, 142, 35, 0.3)',
            successText: '#8fbc1e',
            error: '#c85050',
            errorBg: 'rgba(200, 80, 80, 0.15)',
            errorBorder: 'rgba(200, 80, 80, 0.4)',
            errorShadow: 'rgba(200, 80, 80, 0.3)',
            errorText: '#ff6b6b'
        };
        
        // Button styles
        const BTN_STYLES = {
            selected: 'linear-gradient(180deg, #6b8e23 0%, #5a7a1c 100%)',
            unselected: 'linear-gradient(180deg, #555 0%, #444 100%)',
            selectedBorder: '#8fbc1e',
            unselectedBorder: '#666'
        };
        
        // Mission history
        const missionHistory = [];
        let currentHistoryIndex = -1;
        let isLoadingFromHistory = false;
        
        // Helper: Format position for display (grid or meters)
        function formatPositionDisplay(pos, inputMode) {
            if (inputMode === 'grid') {
                return MortarCalculator.metersToGrid(pos.x, pos.y, true);
            } else {
                return `${Math.round(pos.x)}/${Math.round(pos.y)}`;
            }
        }
        
        function captureCurrentInputs() {
            return {
                mortarType: document.getElementById('mortarType').value,
                shellType: document.getElementById('shellType').value,
                ffeEnabled: document.getElementById('ffeEnabled').checked,
                ffePattern: document.getElementById('ffePattern').value,
                ffeRounds: parseInt(document.getElementById('ffeRounds').value),
                ffeSpacing: parseFloat(document.getElementById('ffeSpacing').value),
                ffeRadius: parseFloat(document.getElementById('ffeRadius').value),
                missionLabel: document.getElementById('missionLabel').value.trim()
            };
        }
        
        function setInputsFromData(data) {
            document.getElementById('mortarType').value = data.mortarType;
            updateShellTypes();
            document.getElementById('shellType').value = data.shellType;
            document.getElementById('missionLabel').value = data.missionLabel || '';
            
            document.getElementById('ffeEnabled').checked = data.ffeEnabled;
            setDisplay(document.getElementById('ffeControls'), data.ffeEnabled);
            
            if (data.ffeEnabled) {
                document.getElementById('ffePattern').value = data.ffePattern;
                document.getElementById('ffeRounds').value = data.ffeRounds;
                document.getElementById('ffeSpacing').value = data.ffeSpacing;
                document.getElementById('ffeRadius').value = data.ffeRadius;
                
                const isCircular = data.ffePattern === 'circular';
                setDisplay(document.getElementById('ffeSpacingGroup'), !isCircular);
                setDisplay(document.getElementById('ffeRadiusGroup'), isCircular);
            }
        }
        
        function setPositionInputs(mortarPos, targetPos) {
            const isGridMode = document.getElementById('targetGridMode').classList.contains('active');
            
            // Mortar position
            if (isGridMode) {
                const mortarGrid = MortarCalculator.metersToGrid(mortarPos.x, mortarPos.y, true).split('/');
                document.getElementById('mortarGridX').value = mortarGrid[0];
                document.getElementById('mortarGridY').value = mortarGrid[1];
            } else {
                document.getElementById('mortarX').value = mortarPos.x.toFixed(1);
                document.getElementById('mortarY').value = mortarPos.y.toFixed(1);
            }
            document.getElementById('mortarZ').value = mortarPos.z.toFixed(1);
            
            // Target position
            if (isGridMode) {
                const targetGrid = MortarCalculator.metersToGrid(targetPos.x, targetPos.y, true).split('/');
                document.getElementById('targetGridX').value = targetGrid[0];
                document.getElementById('targetGridY').value = targetGrid[1];
            } else {
                document.getElementById('targetX').value = targetPos.x.toFixed(1);
                document.getElementById('targetY').value = targetPos.y.toFixed(1);
            }
            document.getElementById('targetZ').value = targetPos.z.toFixed(1);
        }
        
        function addToHistory(mortarPos, targetPos, distance, solutions) {
            if (isLoadingFromHistory) return;
            
            const isGridMode = document.getElementById('targetGridMode').classList.contains('active');
            
            // Safely get correction values from inputs or stored window state
            let correctionLR = 0;
            let correctionAD = 0;
            if (window.correctionApplied) {
                const corrLREl = document.getElementById('correctionLR');
                const corrADEl = document.getElementById('correctionAD');
                correctionLR = window.lastCorrectionLR || (corrLREl ? parseFloat(corrLREl.value) || 0 : 0);
                correctionAD = window.lastCorrectionAD || (corrADEl ? parseFloat(corrADEl.value) || 0 : 0);
            }
            
            const entry = {
                id: Date.now(),
                timestamp: new Date(),
                ...captureCurrentInputs(),
                mortarPos,
                targetPos,
                distance,
                inputMode: isGridMode ? 'grid' : 'meters',
                correctionApplied: window.correctionApplied || false,
                originalTargetPos: window.originalTargetPos || null,
                correctionLR: correctionLR,
                correctionAD: correctionAD
            };
            
            missionHistory.unshift(entry);
            if (missionHistory.length > 20) missionHistory.pop();
            
            currentHistoryIndex = 0;
            updateHistoryDisplay();
        }
        
        function loadFromHistory(index) {
            if (index < 0 || index >= missionHistory.length) return;
            
            const entry = missionHistory[index];
            currentHistoryIndex = index;
            
            isLoadingFromHistory = true;
            
            // Switch to the correct coordinate input mode
            const targetMode = entry.inputMode || 'grid';
            setCoordMode(targetMode);
            
            setInputsFromData(entry);
            setPositionInputs(entry.mortarPos, entry.targetPos);
            
            calculateSolution();
            updateHistoryDisplay();
            
            setTimeout(() => {
                isLoadingFromHistory = false;
            }, 100);
        }
        
        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            const historyPanel = document.getElementById('historyPanel');
            
            if (missionHistory.length === 0) {
                setDisplay(historyPanel, false);
                return;
            }
            
            setDisplay(historyPanel, true);
            
            historyList.innerHTML = missionHistory.map((entry, index) => {
                const time = entry.timestamp.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                
                const mortarDisplay = formatPositionDisplay(entry.mortarPos, entry.inputMode);
                const targetDisplay = formatPositionDisplay(entry.targetPos, entry.inputMode);
                
                const mortarName = getAllMortarTypes().find(m => m.id === entry.mortarType)?.name || entry.mortarType;
                const ffeInfo = entry.ffeEnabled ? ` | FFE: ${entry.ffeRounds} rds` : '';
                const labelDisplay = entry.missionLabel ? `<strong style="color: #8fbc1e;">${entry.missionLabel}</strong> - ` : '';
                const correctionInfo = entry.correctionApplied 
                    ? `<span style="color: ${COLORS.errorText}; font-weight: 600;"> | üî¥ CORRECTED (L/R: ${entry.correctionLR > 0 ? '+' : ''}${entry.correctionLR}m, A/D: ${entry.correctionAD > 0 ? '+' : ''}${entry.correctionAD}m)</span>` 
                    : '';
                
                return `
                    <div class="history-item ${index === currentHistoryIndex ? 'active' : ''}" onclick="loadFromHistory(${index})">
                        <div class="history-header">
                            <div>
                                <span class="history-time">${time}</span>
                                <span class="history-title">${labelDisplay}${mortarName} ${entry.shellType}</span>
                            </div>
                            <button class="history-delete" onclick="deleteFromHistory(${index}, event)" title="Delete mission">üóëÔ∏è</button>
                        </div>
                        <div class="history-details">
                            üìç ${mortarDisplay} ‚Üí üéØ ${targetDisplay} | ${entry.distance.toFixed(0)}m${ffeInfo}${correctionInfo}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function clearHistory() {
            missionHistory.length = 0;
            currentHistoryIndex = -1;
            updateHistoryDisplay();
        }
        
        function deleteFromHistory(index, event) {
            event.stopPropagation();
            
            missionHistory.splice(index, 1);
            
            if (currentHistoryIndex === index) {
                currentHistoryIndex = -1;
            } else if (currentHistoryIndex > index) {
                currentHistoryIndex--;
            }
            
            updateHistoryDisplay();
        }
        
        // Generate info banner HTML
        function createInfoBanner(message, type = 'info') {
            const styles = {
                info: { bg: 'rgba(60, 75, 50, 0.4)', border: '#6b8e23', color: '#d8e4b0' },
                warning: { bg: 'rgba(255, 165, 0, 0.15)', border: 'rgba(255, 165, 0, 0.4)', color: '#ffcc99' },
                error: { bg: 'rgba(255, 107, 107, 0.15)', border: 'rgba(255, 107, 107, 0.3)', color: '#ff9999' }
            };
            const style = styles[type] || styles.info;
            return `<div style="background: ${style.bg}; padding: 10px; border-radius: 4px; border: 1px solid ${style.border}; margin-bottom: 15px; color: ${style.color}; font-size: 13px;">${message}</div>`;
        }
        
        // Populate select dropdown with options
        function populateSelect(select, items, valueKey, textKey) {
            select.innerHTML = '';
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[textKey];
                select.appendChild(option);
            });
        }
        
        // Get FFE control elements
        function getFFEControls() {
            return {
                enabled: document.getElementById('ffeEnabled'),
                controls: document.getElementById('ffeControls'),
                pattern: document.getElementById('ffePattern'),
                spacingGroup: document.getElementById('ffeSpacingGroup'),
                radiusGroup: document.getElementById('ffeRadiusGroup')
            };
        }
        
        // Set element display style
        function setDisplay(element, visible) {
            element.style.display = visible ? 'block' : 'none';
        }
        
        // Get all target input elements
        function getTargetInputs() {
            return {
                gridX: document.getElementById('targetGridX'),
                gridY: document.getElementById('targetGridY'),
                x: document.getElementById('targetX'),
                y: document.getElementById('targetY')
            };
        }
        
        // Clear or set highlighting on target fields
        function setTargetHighlight(color = '') {
            const inputs = getTargetInputs();
            Object.values(inputs).forEach(input => {
                if (input) input.style.color = color;
            });
        }
        
        // Reset Fire for Effect controls to defaults
        function resetFFEControls() {
            const ffe = getFFEControls();
            ffe.enabled.checked = false;
            setDisplay(ffe.controls, false);
            ffe.pattern.value = 'perpendicular';
            document.getElementById('ffeRounds').value = '5';
            document.getElementById('ffeSpacing').value = '50';
            document.getElementById('ffeRadius').value = '100';
            setDisplay(ffe.spacingGroup, true);
            setDisplay(ffe.radiusGroup, false);
        }
        
        // Clear all coordinate input fields
        function clearAllInputs() {
            INPUT_IDS.ALL_COORD_FIELDS.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = '';
            });
        }
        
        // Clear/reset output display
        function clearOutput() {
            const output = document.getElementById('output');
            output.innerHTML = '';
            output.className = 'result';
        }
        
        // Show error in output
        function showOutputError(title, message) {
            const output = document.getElementById('output');
            output.className = 'result active error';
            output.innerHTML = `
                <h2>‚ùå ${title}</h2>
                <p><strong>Error:</strong> ${message}</p>
            `;
        }
        
        // Generate solution grid HTML (used in FFE and normal missions)
        function generateSolutionGridHTML(solution, previousChargeForDisplay) {
            const correctionColor = window.correctionApplied ? COLORS.errorText : '';
            const normalColor = window.correctionApplied ? COLORS.errorText : '#95a585';
            const chargeChanged = typeof previousChargeForDisplay === 'number' && previousChargeForDisplay !== solution.charge;
            
            return `
                <div class="solution-grid">
                    <div class="solution-item">
                        <strong>CHARGE</strong>
                        <div class="value" ${chargeChanged ? `style="color: ${COLORS.errorText}"` : ''}>${solution.charge}</div>
                        ${chargeChanged ? `<div style="color: ${COLORS.errorText}; font-size: 11px; margin-top: 2px;">was: ${previousChargeForDisplay}</div>` : ''}
                    </div>
                    <div class="solution-item">
                        <strong>AZIMUTH</strong>
                        <div class="value" ${correctionColor ? `style="color: ${correctionColor}"` : ''}>${solution.azimuthMils} mils</div>
                        <div style="color: ${normalColor}; font-size: 12px;">(${solution.azimuth}¬∞)</div>
                    </div>
                    <div class="solution-item">
                        <strong>ELEVATION</strong>
                        <div class="value" ${correctionColor ? `style="color: ${correctionColor}"` : ''}>${solution.elevation} mils</div>
                        <div style="color: ${normalColor}; font-size: 12px;">(${solution.elevationDegrees}¬∞)</div>
                        ${solution.elevationCorrection && solution.elevationCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">dElev: ${solution.dElev} and Elevation Correction: ${solution.elevationCorrection > 0 ? '+' : ''}${solution.elevationCorrection.toFixed(1)} mils</div>` : ''}
                    </div>
                    <div class="solution-item">
                        <strong>TIME OF FLIGHT</strong>
                        <div class="value">${solution.timeOfFlight}s</div>
                        ${solution.tofCorrection && solution.tofCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">Correction: ${solution.tofCorrection > 0 ? '+' : ''}${solution.tofCorrection.toFixed(1)}s (TOF/100m: ${solution.tofPer100m})</div>` : ''}
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(20, 25, 22, 0.6); border-radius: 3px; font-size: 12px; color: #a8b898;">
                    <strong>Charge Range:</strong> ${solution.minRange}m - ${solution.maxRange}m
                </div>
            `;
        }
        
        // Generate mission card HTML for optimal or alternative missions
        function generateMissionCardHTML(solution, index, previousChargeForDisplay, solutions) {
            let trajectoryLabel;
            if (index === 0) {
                trajectoryLabel = 'üéØ Optimal Fire Mission';
            } else {
                trajectoryLabel = solution.trajectoryType === 'high' 
                    ? 'üîÑ Alternative Fire Mission (High Angle)' 
                    : 'üîÑ Alternative Fire Mission (Low Angle)';
            }
            
            let chargeDesc = '';
            if (index === 0) {
                chargeDesc = solutions.length > 1 
                    ? `Fastest - ${solution.timeOfFlight}s flight time`
                    : 'Optimal solution';
            } else {
                const timeDiff = solution.timeOfFlight - solutions[0].timeOfFlight;
                const elevDiff = solution.elevation - solutions[0].elevation;
                const elevDegDiff = MortarCalculator.milsToDegrees(solution.elevation, window.lastInput.mortarType) - MortarCalculator.milsToDegrees(solutions[0].elevation, window.lastInput.mortarType);
                const elevSign = elevDiff > 0 ? '+' : '';
                chargeDesc = `+${timeDiff.toFixed(1)}s slower, ${elevSign}${elevDiff} mils (${elevSign}${elevDegDiff.toFixed(1)}¬∞) vs charge ${solutions[0].charge}`;
            }
            
            return `
                <div ${index > 0 ? 'id="altMission_' + index + '" class="alternativeMission"' : ''} style="${index > 0 ? 'display: none; ' : ''}background: ${index === 0 ? 'rgba(40, 55, 45, 0.9)' : 'rgba(35, 45, 42, 0.7)'}; padding: 15px; border-radius: 4px; margin-bottom: 10px; border: ${index === 0 ? '2px solid #6b8e23' : '1px solid #4a5a52'};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0; font-size: 16px; color: ${index === 0 ? '#c8d4a0' : '#a8b898'};">
                            ${trajectoryLabel} - Charge ${solution.charge}
                        </h3>
                        <span style="font-size: 12px; color: #95a585; font-style: italic;">
                            ${chargeDesc}
                        </span>
                    </div>
                    ${generateSolutionGridHTML(solution, previousChargeForDisplay)}
                    <button class="btn-press" onclick="selectMission(${solution.charge})" id="selectBtn_${solution.charge}" style="width: 100%; margin-top: 10px; padding: 8px; background: ${index === 0 ? BTN_STYLES.selected : BTN_STYLES.unselected}; border: 1px solid ${index === 0 ? BTN_STYLES.selectedBorder : BTN_STYLES.unselectedBorder}; border-radius: 4px; color: white; font-weight: 600; cursor: pointer; font-size: 13px;">
                        ${index === 0 ? '‚úì Selected Mission' : 'Use This Mission'}
                    </button>
                </div>
            `;
        }
        
        // Toggle between grid and meters coordinate input
        function setCoordMode(mode) {
            const gridModes = document.querySelectorAll('#mortarGridMode, #targetGridMode');
            const meterModes = document.querySelectorAll('#mortarMetersMode, #targetMetersMode');
            const toggleGrid = document.getElementById('toggleGrid');
            const toggleMeters = document.getElementById('toggleMeters');
            
            if (mode === 'grid') {
                gridModes.forEach(el => el.classList.add('active'));
                meterModes.forEach(el => el.classList.remove('active'));
                toggleGrid.classList.add('active');
                toggleMeters.classList.remove('active');
            } else {
                gridModes.forEach(el => el.classList.remove('active'));
                meterModes.forEach(el => el.classList.add('active'));
                toggleGrid.classList.remove('active');
                toggleMeters.classList.add('active');
            }
            
            // Clear all input fields
            clearAllInputs();
            
            // Clear red highlighting
            setTargetHighlight();
            
            // Reset correction flag
            window.correctionApplied = false;
            
            // Reset Fire for Effect
            resetFFEControls();
            
            // Clear output
            clearOutput();
        }
        
        // Update correction preview to show doctrinal terms
        function updateCorrectionPreview() {
            const correctionLRInput = document.getElementById('correctionLR');
            const correctionADInput = document.getElementById('correctionAD');
            const correctionPreview = document.getElementById('correctionPreview');
            const correctionText = document.getElementById('correctionText');
            
            const lr = parseFloat(correctionLRInput.value) || 0;
            const ad = parseFloat(correctionADInput.value) || 0;
            
            if (lr === 0 && ad === 0) {
                setDisplay(correctionPreview, false);
                return;
            }
            
            const lrText = lr === 0 ? '' : (lr > 0 ? `Right ${Math.abs(lr)}` : `Left ${Math.abs(lr)}`);
            const adText = ad === 0 ? '' : (ad > 0 ? `Add ${Math.abs(ad)}` : `Drop ${Math.abs(ad)}`);
            
            let resultText = '';
            if (lrText && adText) {
                resultText = `${lrText}, ${adText}`;
            } else if (lrText) {
                resultText = lrText;
            } else if (adText) {
                resultText = adText;
            }
            
            correctionText.textContent = resultText;
            correctionPreview.style.display = 'block';
        }
        
        // Parse position from UI inputs (grid or meters mode)
        function parsePositionFromUI(prefix, allowNull = false) {
            const gridX = document.getElementById(`${prefix}GridX`).value.trim();
            const gridY = document.getElementById(`${prefix}GridY`).value.trim();
            const z = parseFloat(document.getElementById(`${prefix}Z`).value) || 0;
            
            if (gridX && gridY) {
                const grid = gridX + '/' + gridY;
                return MortarCalculator.parsePosition({ grid, z });
            } else {
                const x = parseFloat(document.getElementById(`${prefix}X`).value);
                const y = parseFloat(document.getElementById(`${prefix}Y`).value);
                if (!isNaN(x) && !isNaN(y)) {
                    return { x, y, z };
                } else if (!allowNull) {
                    // Highlight missing fields before throwing error
                    highlightMissingFields(prefix);
                    throw new Error(`Enter either grid coordinates or X/Y meter values for ${prefix}`);
                }
                return null;
            }
        }
        
        // Highlight missing input fields
        function highlightMissingFields(prefix) {
            const gridX = document.getElementById(`${prefix}GridX`);
            const gridY = document.getElementById(`${prefix}GridY`);
            const meterX = document.getElementById(`${prefix}X`);
            const meterY = document.getElementById(`${prefix}Y`);
            
            // Check which mode should have values
            const gridXVal = gridX.value.trim();
            const gridYVal = gridY.value.trim();
            const meterXVal = meterX.value.trim();
            const meterYVal = meterY.value.trim();
            
            // If partial grid input, highlight missing grid fields
            if (gridXVal || gridYVal) {
                if (!gridXVal) highlightField(gridX);
                if (!gridYVal) highlightField(gridY);
            }
            // If partial meter input, highlight missing meter fields
            else if (meterXVal || meterYVal) {
                if (!meterXVal) highlightField(meterX);
                if (!meterYVal) highlightField(meterY);
            }
            // No input at all, highlight all primary fields based on active mode
            else {
                const isGridMode = document.getElementById(`${prefix}GridMode`)?.classList.contains('active');
                if (isGridMode) {
                    highlightField(gridX);
                    highlightField(gridY);
                } else {
                    highlightField(meterX);
                    highlightField(meterY);
                }
            }
        }
        
        // Highlight a single field with error styling
        function highlightField(element) {
            if (!element) return;
            element.style.borderColor = COLORS.error;
            element.style.boxShadow = `0 0 8px ${COLORS.errorShadow}`;
            
            // Add pulse animation
            element.style.animation = 'pulse 0.5s ease-in-out 2';
        }
        
        // Clear error styling from a single field
        function clearFieldErrorStyling(element) {
            if (!element) return;
            element.style.borderColor = '';
            element.style.boxShadow = '';
            element.style.animation = '';
        }
        
        // Clear field highlighting
        function clearFieldHighlighting(prefix) {
            const fields = [
                document.getElementById(`${prefix}GridX`),
                document.getElementById(`${prefix}GridY`),
                document.getElementById(`${prefix}X`),
                document.getElementById(`${prefix}Y`)
            ];
            
            fields.forEach(clearFieldErrorStyling);
        }
        
        // Validate grid coordinate format in real-time
        function validateGridFormat(input) {
            const value = input.value.trim();
            
            // Empty is OK (user might be typing)
            if (!value) {
                input.style.borderColor = '';
                input.style.boxShadow = '';
                return true;
            }
            
            // Grid coordinates must be 3-4 digits
            const isValid = /^\d{3,4}$/.test(value);
            
            if (!isValid) {
                input.style.borderColor = COLORS.error;
                input.style.boxShadow = `0 0 8px ${COLORS.errorShadow}`;
                
                // Show warning message
                const rangeIndicator = document.getElementById('rangeIndicator');
                if (rangeIndicator) {
                    rangeIndicator.innerHTML = `<span style="color: ${COLORS.errorText};">‚ö†Ô∏è Grid coordinates must be 3-4 digits (e.g., 047 or 0475)</span>`;
                }
            } else {
                input.style.borderColor = '';
                input.style.boxShadow = '';
            }
            
            return isValid;
        }
        
        // Helper: Create or update range indicator
        function updateRangeIndicatorDisplay(inRange, distance, solution) {
            const targetInputs = getTargetInputs();
            let rangeIndicator = document.getElementById('rangeIndicator');
            
            if (!rangeIndicator) {
                rangeIndicator = document.createElement('div');
                rangeIndicator.id = 'rangeIndicator';
                rangeIndicator.style.cssText = 'margin-top: 8px; padding: 8px; border-radius: 4px; font-size: 12px; font-weight: 600;';
                const firstTargetInput = targetInputs.gridX || targetInputs.x;
                if (firstTargetInput && firstTargetInput.parentElement) {
                    firstTargetInput.parentElement.appendChild(rangeIndicator);
                }
            }
            
            if (inRange) {
                rangeIndicator.textContent = `‚úì Range: ${Math.round(distance)}m (Charge ${solution.charge})`;
                rangeIndicator.style.background = COLORS.successBg;
                rangeIndicator.style.border = `1px solid ${COLORS.successBorder}`;
                rangeIndicator.style.color = COLORS.successText;
            } else {
                rangeIndicator.textContent = `‚ö† Range: ${Math.round(distance)}m - Out of range for all charges`;
                rangeIndicator.style.background = COLORS.errorBg;
                rangeIndicator.style.border = `1px solid ${COLORS.errorBorder}`;
                rangeIndicator.style.color = COLORS.errorText;
            }
        }
        
        // Real-time range validation
        function validateCoordinateRange() {
            if (!ballisticDataLoaded) return;
            
            // First validate grid format if using grid coordinates
            const gridInputs = [
                document.getElementById('mortarGridX'),
                document.getElementById('mortarGridY'),
                document.getElementById('targetGridX'),
                document.getElementById('targetGridY')
            ];
            
            let hasFormatError = false;
            gridInputs.forEach(input => {
                if (input && input.value.trim()) {
                    if (!validateGridFormat(input)) {
                        hasFormatError = true;
                    }
                }
            });
            
            // Don't proceed with range validation if there's a format error
            if (hasFormatError) return;
            
            try {
                const mortarId = document.getElementById('mortarType').value;
                const shellType = document.getElementById('shellType').value;
                
                const mortarPos = parsePositionFromUI('mortar', true);
                const targetPos = parsePositionFromUI('target', true);
                
                // Clear validation if incomplete
                if (!mortarPos || !targetPos) {
                    clearRangeValidation();
                    return;
                }
                
                // Get weapon config to check range (includes distance calculation)
                const input = MortarCalculator.prepareInput(mortarPos, targetPos, mortarId, shellType);
                const solutions = MortarCalculator.calculateAllTrajectories(input);
                const distance = input.distance;
                
                const inRange = solutions.length > 0 && solutions[0].inRange;
                
                // Apply visual feedback
                const targetInputs = getTargetInputs();
                
                Object.values(targetInputs).forEach(input => {
                    if (input && input.value.trim()) {
                        if (inRange) {
                            input.style.borderColor = COLORS.success;
                            input.style.boxShadow = `0 0 0 1px ${COLORS.successShadow}`;
                        } else {
                            input.style.borderColor = COLORS.error;
                            input.style.boxShadow = `0 0 0 1px ${COLORS.errorShadow}`;
                        }
                    }
                });
                
                // Show range indicator
                let rangeIndicator = document.getElementById('rangeIndicator');
                if (!rangeIndicator) {
                    rangeIndicator = document.createElement('div');
                    rangeIndicator.id = 'rangeIndicator';
                    rangeIndicator.style.cssText = 'margin-top: 10px; padding: 8px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; transition: all 0.3s;';
                    document.querySelector('#targetZ').parentElement.insertAdjacentElement('afterend', rangeIndicator);
                }
                
                if (inRange) {
                    rangeIndicator.style.background = COLORS.successBg;
                    rangeIndicator.style.border = `1px solid ${COLORS.successBorder}`;
                    rangeIndicator.style.color = COLORS.successText;
                    rangeIndicator.innerHTML = `‚úì In Range: ${distance.toFixed(0)}m (${solutions[0].minRange}m - ${solutions[0].maxRange}m)`;
                } else {
                    const solution = solutions[0];
                    rangeIndicator.style.background = COLORS.errorBg;
                    rangeIndicator.style.border = `1px solid ${COLORS.errorBorder}`;
                    rangeIndicator.style.color = COLORS.errorText;
                    if (solution.minRange && solution.maxRange) {
                        const tooClose = distance < solution.minRange;
                        rangeIndicator.innerHTML = `‚ö† Out of Range: ${distance.toFixed(0)}m (valid: ${solution.minRange}m - ${solution.maxRange}m) - Target is ${tooClose ? 'too close' : 'too far'}`;
                    } else {
                        rangeIndicator.innerHTML = `‚ö† Out of Range: ${distance.toFixed(0)}m`;
                    }
                }
                
            } catch (error) {
                clearRangeValidation();
            }
        }
        
        function clearRangeValidation() {
            const targetInputs = getTargetInputs();
            
            Object.values(targetInputs).forEach(input => {
                if (input) {
                    input.style.borderColor = '';
                    input.style.boxShadow = '';
                }
            });
            
            const rangeIndicator = document.getElementById('rangeIndicator');
            if (rangeIndicator) {
                rangeIndicator.remove();
            }
        }
        
        // Apply fire correction to target position
        function applyFireCorrectionUI() {
            const correctionLR = parseFloat(document.getElementById('correctionLR').value) || 0;
            const correctionAD = parseFloat(document.getElementById('correctionAD').value) || 0;
            
            if (correctionLR === 0 && correctionAD === 0) {
                return;
            }
            
            // Store correction values for history
            window.lastCorrectionLR = correctionLR;
            window.lastCorrectionAD = correctionAD;
            
            try {
                const mortarPos = parsePositionFromUI('mortar');
                const targetPos = parsePositionFromUI('target');
                
                // Store original target position before correction
                if (!window.originalTargetPos) {
                    window.originalTargetPos = {...targetPos};
                }
                
                // Apply fire correction
                const corrected = MortarCalculator.applyFireCorrection(mortarPos, targetPos, correctionLR, correctionAD);
                
                // Update target fields with corrected position and highlight in red
                const inputs = getTargetInputs();
                
                inputs.x.value = corrected.x.toFixed(1);
                inputs.y.value = corrected.y.toFixed(1);
                setTargetHighlight(COLORS.errorText);
                
                // Convert to grid if in grid mode
                const gridMode = document.getElementById('targetGridMode').classList.contains('active');
                if (gridMode) {
                    const gridCoords = MortarCalculator.metersToGrid(corrected.x, corrected.y, true);
                    const gridParts = gridCoords.split('/');
                    inputs.gridX.value = gridParts[0];
                    inputs.gridY.value = gridParts[1];
                }
                
                // Store previous charge before recalculation
                window.previousCharge = window.selectedCharge || (window.lastSolution ? window.lastSolution.charge : null);
                
                // Mark that correction was applied (for highlighting output)
                window.correctionApplied = true;
                
                // Automatically recalculate firing mission with SELECTED CHARGE
                calculateSolution();
                
            } catch (error) {
                console.error('Correction error:', error);
                showOutputError('Correction Error', error.message);
            }
        }
        
        // Get all available mortar types from loaded ballistic data
        function getAllMortarTypes() {
            try {
                return MortarCalculator.getAllMortarTypes();
            } catch (error) {
                console.warn('Could not get mortar types:', error);
                return [];
            }
        }
        
        // Get available shell types for a mortar from loaded ballistic data
        function getShellTypesForMortar(mortarId) {
            try {
                const config = MortarCalculator.getWeaponConfig(mortarId, 'HE');
                const mortar = config.mortar;
                
                return mortar.shellTypes.map(shell => ({
                    value: shell.type,
                    label: shell.name
                }));
            } catch (error) {
                console.warn('Could not get shell types:', error);
                return [];
            }
        }
        
        // Update mortar type options from ballistic data
        function updateMortarTypes() {
            const mortarTypeSelect = document.getElementById('mortarType');
            const currentValue = mortarTypeSelect.value;
            
            const availableMortars = getAllMortarTypes();
            
            // Sort: US mortars first, then others
            availableMortars.sort((a, b) => {
                const aIsUS = a.id === 'US' || a.id.startsWith('US_');
                const bIsUS = b.id === 'US' || b.id.startsWith('US_');
                if (aIsUS && !bIsUS) return -1;
                if (!aIsUS && bIsUS) return 1;
                return a.name.localeCompare(b.name);
            });
            
            populateSelect(mortarTypeSelect, availableMortars, 'id', 'name');
            
            // Restore previous selection if available, otherwise select US mortar
            const optionExists = availableMortars.some(m => m.id === currentValue);
            if (optionExists) {
                mortarTypeSelect.value = currentValue;
            } else if (availableMortars.length > 0) {
                const usMortar = availableMortars.find(m => m.id === 'US' || m.id.startsWith('US_'));
                mortarTypeSelect.value = usMortar ? usMortar.id : availableMortars[0].id;
            }
        }
        
        // Update shell type options based on mortar type
        function updateShellTypes() {
            const mortarType = document.getElementById('mortarType').value;
            const shellTypeSelect = document.getElementById('shellType');
            const currentValue = shellTypeSelect.value;
            
            const availableShells = getShellTypesForMortar(mortarType);
            
            populateSelect(shellTypeSelect, availableShells, 'value', 'label');
            
            // Restore previous selection if available, otherwise select first
            const optionExists = availableShells.some(s => s.value === currentValue);
            if (optionExists) {
                shellTypeSelect.value = currentValue;
            } else if (availableShells.length > 0) {
                shellTypeSelect.value = availableShells[0].value;
            }
        }
        
        // Load ballistic data on page load
        async function init() {
            const loading = document.getElementById('loading');
            const app = document.getElementById('app');
            
            try {
                await MortarCalculator.loadBallisticData('ballistic-data.json');
                ballisticDataLoaded = true;
                
                setDisplay(loading, false);
                setDisplay(app, true);
                
                // Initialize mortar types and shell types after data is loaded
                updateMortarTypes();
                updateShellTypes();
                
                console.log('‚úÖ Ballistic data loaded successfully');
            } catch (error) {
                loading.innerHTML = `
                    <div style="color: red;">
                        ‚ùå Error loading ballistic data: ${error.message}
                        <br>Make sure the HTTP server is running from the mortar_core directory.
                    </div>
                `;
                console.error('Error loading ballistic data:', error);
            }
        }
        
        // Setup event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const calculateBtn = document.getElementById('calculate');
            const mortarTypeSelect = document.getElementById('mortarType');
            
            // Update shell types when mortar type changes
            mortarTypeSelect.addEventListener('change', updateShellTypes);
            
            calculateBtn.addEventListener('click', calculateSolution);
            
            // Fire for Effect toggle
            const ffe = getFFEControls();
            ffe.enabled.addEventListener('change', function() {
                setDisplay(ffe.controls, this.checked);
                
                // Recalculate when FFE is toggled
                const output = document.getElementById('output');
                if (output.classList.contains('active')) {
                    calculateSolution();
                }
            });
            
            // Fire for Effect pattern type change
            ffe.pattern.addEventListener('change', function() {
                const isCircular = this.value === 'circular';
                setDisplay(ffe.spacingGroup, !isCircular);
                setDisplay(ffe.radiusGroup, isCircular);
            });
            
            // Reset button
            const resetBtn = document.getElementById('reset');
            resetBtn.addEventListener('click', function() {
                // Clear all input fields
                clearAllInputs();
                
                // Clear red highlighting from corrected fields
                setTargetHighlight();
                
                // Clear range validation
                clearRangeValidation();
                
                // Reset correction flag and original position
                window.correctionApplied = false;
                window.originalTargetPos = null;
                window.lastCorrectionLR = null;
                window.lastCorrectionAD = null;
                
                // Reset Fire for Effect
                resetFFEControls();
                
                // Clear output and remove error class
                clearOutput();
            });
            
            // Clear red highlighting when user manually edits target fields
            INPUT_IDS.TARGET_FIELDS.forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', function() {
                    this.style.color = '';
                    clearFieldErrorStyling(this);
                    window.correctionApplied = false;
                    window.originalTargetPos = null;
                    window.lastCorrectionLR = null;
                    window.lastCorrectionAD = null;
                    // Trigger range validation (includes format validation)
                    validateCoordinateRange();
                });
            });
            
            // Add range validation to all coordinate inputs
            INPUT_IDS.MORTAR_FIELDS.forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', function() {
                    clearFieldErrorStyling(this);
                    validateCoordinateRange();
                });
            });
            
            // Trigger validation when mortar type or shell type changes
            document.getElementById('mortarType').addEventListener('change', validateCoordinateRange);
            document.getElementById('shellType').addEventListener('change', validateCoordinateRange);
            
            // Allow Enter key to trigger calculation
            document.querySelectorAll('input').forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') calculateSolution();
                });
            });
            
            // Setup event delegation for dynamically created correction controls
            document.addEventListener('input', function(e) {
                if (e.target.id === 'correctionLR' || e.target.id === 'correctionAD') {
                    updateCorrectionPreview();
                }
            });
        });
        
        // Toggle visibility of alternative fire missions
        function toggleAlternativeMissions() {
            const altMissions = document.querySelectorAll('.alternativeMission');
            const btn = document.getElementById('toggleAltBtn');
            const isHidden = altMissions[0] && altMissions[0].style.display === 'none';
            
            altMissions.forEach(mission => {
                mission.style.display = isHidden ? 'block' : 'none';
            });
            
            if (btn) {
                btn.textContent = isHidden 
                    ? `‚ñ≤ Hide Alternative Mission${altMissions.length > 1 ? 's' : ''}`
                    : `‚ñº Show ${altMissions.length} Alternative Mission${altMissions.length > 1 ? 's' : ''}`;
            }
        }
        
        // Select a specific fire mission for correction
        function selectMission(charge) {
            window.selectedCharge = charge;
            
            // Store the original optimal charge if not already stored
            if (window.originalOptimalCharge === undefined && window.lastSolutions && window.lastSolutions.length > 0) {
                window.originalOptimalCharge = window.lastSolutions[0].charge;
            }
            
            // Find the correction widget and all mission elements
            const correctionWidget = document.getElementById('fireCorrectionWidget');
            const selectedBtn = document.getElementById(`selectBtn_${charge}`);
            
            if (correctionWidget && selectedBtn) {
                // Find the selected mission card
                const selectedCard = selectedBtn.closest('div[style*="background"]');
                
                if (selectedCard && selectedCard.parentNode) {
                    // Get all solution cards
                    const solutions = window.lastSolutions || [];
                    const allCards = [];
                    
                    solutions.forEach(sol => {
                        const btn = document.getElementById(`selectBtn_${sol.charge}`);
                        if (btn) {
                            const card = btn.closest('div[style*="background"]');
                            if (card) {
                                allCards.push({ charge: sol.charge, card: card });
                            }
                        }
                    });
                    
                    // Find the parent container
                    const container = selectedCard.parentNode;
                    
                    // Store the toggle button and alternative missions
                    const toggleBtn = document.getElementById('toggleAltBtn');
                    
                    // Remove all mission cards temporarily
                    allCards.forEach(item => {
                        if (item.card.parentNode) {
                            item.card.remove();
                        }
                    });
                    
                    // Remove toggle button and correction widget temporarily
                    if (correctionWidget.parentNode) correctionWidget.remove();
                    if (toggleBtn && toggleBtn.parentNode) toggleBtn.remove();
                    
                    // Find the selected card object
                    const selectedCardObj = allCards.find(item => item.charge === charge);
                    const otherCards = allCards.filter(item => item.charge !== charge);
                    
                    // Re-insert in new order
                    if (selectedCardObj) {
                        // Insert selected mission first (make it optimal)
                        container.appendChild(selectedCardObj.card);
                        selectedCardObj.card.style.display = 'block';
                        selectedCardObj.card.removeAttribute('id');
                        selectedCardObj.card.classList.remove('alternativeMission');
                        
                        // Update styling to optimal
                        selectedCardObj.card.style.background = 'rgba(40, 55, 45, 0.9)';
                        selectedCardObj.card.style.border = '2px solid #6b8e23';
                        
                        // Update title in the selected card
                        const title = selectedCardObj.card.querySelector('h3');
                        if (title) {
                            title.innerHTML = `üéØ Optimal Fire Mission - Charge ${charge}`;
                        }
                        
                        // Insert correction widget
                        container.appendChild(correctionWidget);
                        correctionWidget.style.display = 'block';
                        
                        // Insert toggle button if there are alternatives
                        if (otherCards.length > 0 && toggleBtn) {
                            container.appendChild(toggleBtn);
                            toggleBtn.textContent = `‚ñº Show ${otherCards.length} Alternative Mission${otherCards.length > 1 ? 's' : ''}`;
                        }
                        
                        // Insert other missions as alternatives (hidden)
                        otherCards.forEach((item, index) => {
                            item.card.id = `altMission_${index + 1}`;
                            item.card.classList.add('alternativeMission');
                            item.card.style.display = 'none';
                            item.card.style.background = 'rgba(35, 45, 42, 0.7)';
                            item.card.style.border = '1px solid #4a5a52';
                            
                            // Mark the original optimal charge
                            const title = item.card.querySelector('h3');
                            if (title && item.charge === window.originalOptimalCharge) {
                                title.innerHTML = `‚≠ê Alternative Fire Mission - Charge ${item.charge} <span style="color: #ffd700; font-size: 11px;">(Original Optimal)</span>`;
                            } else if (title) {
                                title.innerHTML = `üîÑ Alternative Fire Mission - Charge ${item.charge}`;
                            }
                            
                            container.appendChild(item.card);
                        });
                    }
                }
            }
            
            // Update all buttons
            const solutions = window.lastSolutions || [];
            solutions.forEach(sol => {
                const btn = document.getElementById(`selectBtn_${sol.charge}`);
                if (btn) {
                    if (sol.charge === charge) {
                        btn.style.background = BTN_STYLES.selected;
                        btn.style.borderColor = BTN_STYLES.selectedBorder;
                        btn.textContent = '‚úì Selected Mission';
                    } else {
                        btn.style.background = BTN_STYLES.unselected;
                        btn.style.borderColor = BTN_STYLES.unselectedBorder;
                        btn.textContent = 'Use This Mission';
                    }
                }
            });
            
            // Update correction widget header
            const chargeDisplay = document.getElementById('selectedChargeDisplay');
            if (chargeDisplay) {
                chargeDisplay.textContent = `(Charge ${charge})`;
            }
        }
        
        function calculateSolution() {
            if (!ballisticDataLoaded) {
                return;
            }
            
            const output = document.getElementById('output');
            
            // Clear previous results
            output.className = 'result';
            output.innerHTML = '';
            
            try {
                const mortarId = document.getElementById('mortarType').value;
                const shellType = document.getElementById('shellType').value;
                
                // Clear any previous field highlighting
                clearFieldHighlighting('mortar');
                clearFieldHighlighting('target');
                
                const mortarPos = parsePositionFromUI('mortar');
                const targetPos = parsePositionFromUI('target');
                
                // Check if Fire for Effect is enabled
                const ffeEnabled = document.getElementById('ffeEnabled').checked;
                
                if (ffeEnabled) {
                    // Fire for Effect mode
                    const ffePattern = document.getElementById('ffePattern').value;
                    const ffeRounds = parseInt(document.getElementById('ffeRounds').value);
                    
                    // Parse mortar and target positions to ensure they're in {x,y,z} format
                    const mortarParsed = MortarCalculator.parsePosition(mortarPos);
                    const targetParsed = MortarCalculator.parsePosition(targetPos);
                    
                    console.log('üéØ FFE Using Coordinates:');
                    console.log('  Target Position (input):', targetPos);
                    console.log('  Target Position (parsed):', targetParsed);
                    console.log('  Correction Applied:', window.correctionApplied ? 'YES (red coordinates)' : 'NO (original coordinates)');
                    
                    // Generate pattern positions based on pattern type
                    let targetPositions;
                    let patternParam;
                    
                    if (ffePattern === 'circular') {
                        const ffeRadius = parseFloat(document.getElementById('ffeRadius').value) || 100;
                        targetPositions = MortarCalculator.generateCircularPattern(
                            targetParsed,
                            ffeRadius,
                            ffeRounds
                        );
                        patternParam = ffeRadius;
                    } else {
                        const ffeSpacing = parseFloat(document.getElementById('ffeSpacing').value) || 50;
                        targetPositions = MortarCalculator.generateFireForEffectPattern(
                            mortarParsed,
                            targetParsed,
                            ffePattern,
                            ffeRounds,
                            ffeSpacing
                        );
                        patternParam = ffeSpacing;
                    }
                    
                    // Calculate solutions for each position using consistent charge
                    const ffeSolutions = [];
                    
                    // First, determine optimal charge from center target
                    const centerInput = MortarCalculator.prepareInput(mortarPos, targetParsed, mortarId, shellType);
                    const centerSolutions = MortarCalculator.calculateAllTrajectories(centerInput);
                    
                    if (centerSolutions.length === 0 || !centerSolutions[0].inRange) {
                        throw new Error('Center target out of range - cannot calculate FFE pattern');
                    }
                    
                    // Use the optimal charge for all FFE rounds
                    const ffeCharge = centerSolutions[0].charge;
                    
                    targetPositions.forEach((pos, index) => {
                        const input = MortarCalculator.prepareInput(mortarPos, pos, mortarId, shellType);
                        // Force the same charge for all FFE rounds
                        input.chargeLevel = ffeCharge;
                        const solutions = MortarCalculator.calculateAllTrajectories(input);
                        if (solutions.length > 0 && solutions[0].inRange) {
                            ffeSolutions.push({
                                roundNumber: index + 1,
                                targetPos: pos,
                                input: input,
                                solution: solutions[0]
                            });
                        }
                    });
                    
                    // Sort by azimuth for easier gun traverse (always same direction)
                    const sortedFFE = MortarCalculator.sortFFESolutionsByAzimuth(ffeSolutions);
                    
                    // Display FFE results
                    if (sortedFFE.length > 0) {
                        output.className = 'result active success';
                        
                        let patternDesc, patternParamDesc;
                        if (ffePattern === 'perpendicular') {
                            patternDesc = 'Lateral Sheaf (Width Coverage)';
                            patternParamDesc = `Round Interval: ${patternParam}m`;
                        } else if (ffePattern === 'along-bearing') {
                            patternDesc = 'Linear Sheaf (Depth Penetration)';
                            patternParamDesc = `Round Interval: ${patternParam}m`;
                        } else {
                            patternDesc = 'Circular Pattern (Area Saturation)';
                            patternParamDesc = `Circle Radius: ${patternParam}m`;
                        }
                        
                        let ffeHTML = `
                            <h2>üí• Fire for Effect Mission</h2>
                            
                            ${window.correctionApplied ? createInfoBanner('üî¥ <strong>Fire correction applied:</strong> Red values include observer correction', 'error') : ''}
                            
                            ${createInfoBanner(`
                                <strong>üìä Sheaf Type:</strong> ${patternDesc}<br>
                                <strong>üéØ Salvo Size:</strong> ${sortedFFE.length} of ${ffeRounds} rounds (in range)<br>
                                <strong>üìè ${patternParamDesc}</strong>
                            `)}
                            
                            <h3 style="font-size: 16px; margin-bottom: 10px;">Fire Mission Commands</h3>
                        `;
                        
                        // Store previous charge for highlighting
                        const previousChargeForDisplay = window.previousCharge;
                        
                        sortedFFE.forEach(({ roundNumber, targetPos, input, solution }) => {
                            ffeHTML += `
                                <div style="background: rgba(35, 45, 42, 0.85); padding: 15px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #4a5a52;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <h3 style="margin: 0; font-size: 16px; color: #c8d4a0;">
                                            Round ${roundNumber} of ${ffeRounds} - Charge ${solution.charge}
                                        </h3>
                                        <span style="font-size: 12px; color: #95a585; font-style: italic;">
                                            Range: ${input.distance.toFixed(1)}m | Alt Diff: ${input.heightDifference > 0 ? '+' : ''}${input.heightDifference.toFixed(1)}m
                                        </span>
                                    </div>
                                    ${generateSolutionGridHTML(solution, previousChargeForDisplay)}
                                </div>
                            `;
                        });
                        
                        output.innerHTML = ffeHTML;
                        
                        // Clear previous charge after FFE output is complete
                        window.previousCharge = null;
                    } else {
                        throw new Error('No rounds in range for Fire for Effect pattern');
                    }
                    
                    return; // Exit early, don't run normal calculation
                }
                
                // Use prepareInput to calculate range, azimuth, and height difference
                const input = MortarCalculator.prepareInput(mortarPos, targetPos, mortarId, shellType);
                
                console.log('Mortar Position:', mortarPos);
                console.log('Target Position:', targetPos);
                console.log('Calculated Parameters:', {
                    distance: input.distance.toFixed(1) + 'm',
                    bearing: input.bearing.toFixed(1) + '¬∞',
                    bearingMils: MortarCalculator.degreesToMils(input.bearing) + ' mils',
                    heightDifference: input.heightDifference.toFixed(1) + 'm'
                });
                
                console.log('Input:', input);
                
                // Calculate all trajectory options
                let solutions = MortarCalculator.calculateAllTrajectories(input);
                
                // If correction was applied and a charge was selected, keep that charge as primary
                if (window.correctionApplied && window.selectedCharge !== undefined && solutions.length > 0) {
                    const selectedChargeIdx = solutions.findIndex(s => s.charge === window.selectedCharge);
                    if (selectedChargeIdx > 0) {
                        // Move selected charge to first position (keep as optimal)
                        const selectedSolution = solutions.splice(selectedChargeIdx, 1)[0];
                        solutions.unshift(selectedSolution);
                    }
                }
                
                // Store solutions globally for mission selection
                window.lastSolutions = solutions;
                
                // Store the primary solution for charge change detection
                if (solutions.length > 0 && solutions[0].inRange) {
                    window.lastSolution = solutions[0];
                    
                    // Add to mission history
                    addToHistory(mortarPos, targetPos, input.distance, solutions);
                }
                
                console.log('Solutions:', solutions);
                
                // Generate trajectory data using MortarCalculator
                const trajectoryData = MortarCalculator.generateTrajectoryPoints(solutions, input.distance, input.mortarType);
                
                // Render SVG trajectories
                let trajectorySVG = '';
                if (trajectoryData.series && trajectoryData.series.length > 0) {
                    const svgTop = 30;
                    const groundY = 220;
                    const availablePx = groundY - svgTop;
                    const verticalScale = trajectoryData.globalMaxY > 0 ? availablePx / trajectoryData.globalMaxY : 1;
                    
                    trajectoryData.series.forEach((series, i) => {
                        const { color, elevDeg, points, charge, tof } = series;
                        
                        let svgPoints = points.map(p => {
                            const screenX = 50 + (p.x / trajectoryData.globalRange) * 500;
                            const screenY = groundY - p.y * verticalScale;
                            return screenX.toFixed(1) + ',' + screenY.toFixed(1);
                        });
                        
                        svgPoints[svgPoints.length - 1] = '550,' + groundY;
                        
                        const pathData = 'M ' + svgPoints.join(' L ');
                        const legendY = 30 + i * 25;
                        const textY = 34 + i * 25;
                        
                        trajectorySVG += '<path d="' + pathData + '" fill="none" stroke="' + color + '" stroke-width="2.5" opacity="0.8"/>';
                        trajectorySVG += '<circle cx="300" cy="' + legendY + '" r="4" fill="' + color + '"/>';
                        trajectorySVG += '<text x="310" y="' + textY + '" font-size="11" fill="' + color + '" font-weight="bold">';
                        trajectorySVG += 'Charge ' + charge + ': ' + elevDeg.toFixed(1) + '¬∞ (' + tof + 's)</text>';
                    });
                }
                
                // Display result
                output.className = 'result active';
                
                if (solutions.length > 0 && solutions[0].inRange) {
                    output.classList.add('success');
                    
                    let solutionsHTML = '';
                    
                    // Add correction hint if correction was applied
                    if (window.correctionApplied) {
                        solutionsHTML += createInfoBanner('üî¥ <strong>Fire correction applied:</strong> Red values include observer correction', 'error');
                    }
                    
                    // Add charge change warning if charge changed (only if previousCharge is a valid number)
                    if (typeof window.previousCharge === 'number' && window.previousCharge !== solutions[0].charge) {
                        solutionsHTML += createInfoBanner(`‚ö†Ô∏è <strong>Charge changed:</strong> Correction moved target from Charge ${window.previousCharge} to Charge ${solutions[0].charge} (different ballistic trajectory)`, 'warning');
                    }
                    
                    // Store previous charge for highlighting (before clearing)
                    const previousChargeForDisplay = window.previousCharge;
                    
                    let optimalMissionHTML = '';
                    let alternativeMissionsHTML = '';
                    
                    // Store input for mission card generation
                    window.lastInput = input;
                    
                    solutions.forEach((solution, index) => {
                        const missionHTML = generateMissionCardHTML(solution, index, previousChargeForDisplay, solutions);
                        
                        if (index === 0) {
                            optimalMissionHTML = missionHTML;
                        } else {
                            alternativeMissionsHTML += missionHTML;
                        }
                    });
                    
                    output.innerHTML = `
                        <h2>‚úÖ Firing Mission${solutions.length > 1 ? 's' : ''} Found</h2>
                        
                        ${createInfoBanner(`
                            <strong>üìê Mil System:</strong> ${MortarCalculator.getMilSystemName(input.mortarType)} &nbsp;|&nbsp; 
                            <strong style="${window.correctionApplied ? 'color: ' + COLORS.errorText + ';' : ''}">üìè Range:</strong> <span style="${window.correctionApplied ? 'color: ' + COLORS.errorText + ';' : ''}">${input.distance.toFixed(1)}m</span> &nbsp;|&nbsp; 
                            <strong>‚õ∞Ô∏è Alt Diff:</strong> ${input.heightDifference > 0 ? '+' : ''}${input.heightDifference.toFixed(1)}m
                        `)}
                        
                        ${solutions.length > 1 ? createInfoBanner('<strong>üí° Multiple Charge Options Available:</strong><br><small>Lower charges are more accurate but have limited range. Higher charges reach further but are less precise. High angle trajectories can clear obstacles.</small>') : ''}
                        
                        <h3 style="font-size: 16px; margin-bottom: 10px;">Fire Missions (${solutions.length}): <span style="font-size: 16px; color: #ffffff; font-weight: normal;"></span></h3>
                        
                        ${optimalMissionHTML}
                        
                        <!-- Inline Fire Correction Widget -->
                        <div id="fireCorrectionWidget" style="display: none; background: rgba(40, 55, 45, 0.9); padding: 15px; border-radius: 4px; margin-bottom: 10px; border: 2px solid #6b8e23;">
                            <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #c8d4a0;">üîÑ Adjust Fire <span id="selectedChargeDisplay" style="color: #8fbc1e;">(Charge ${solutions[0].charge})</span></h3>
                            <div>
                                <div style="color: #95a585; font-size: 12px; margin-bottom: 12px;">
                                    Observer corrections: Left/Right shifts azimuth. Add/Drop changes range.
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                                    <div>
                                        <label style="display: block; color: #a8b898; font-size: 13px; margin-bottom: 5px; font-weight: 600;">Left/Right (meters)</label>
                                        <input type="number" id="correctionLR" placeholder="0" step="1" value="0" style="width: 100%; padding: 8px; background: rgba(20, 25, 22, 0.8); border: 1px solid #4a5a52; border-radius: 3px; color: #c8d4a0; font-size: 13px;">
                                        <small style="color: #7a8a7a; display: block; margin-top: 3px; font-size: 11px;">Right: +, Left: ‚àí</small>
                                    </div>
                                    <div>
                                        <label style="display: block; color: #a8b898; font-size: 13px; margin-bottom: 5px; font-weight: 600;">Add/Drop (meters)</label>
                                        <input type="number" id="correctionAD" placeholder="0" step="1" value="0" style="width: 100%; padding: 8px; background: rgba(20, 25, 22, 0.8); border: 1px solid #4a5a52; border-radius: 3px; color: #c8d4a0; font-size: 13px;">
                                        <small style="color: #7a8a7a; display: block; margin-top: 3px; font-size: 11px;">Add: +, Drop: ‚àí</small>
                                    </div>
                                </div>
                                <button id="applyCorrection" onclick="const btn = this; btn.style.background = 'linear-gradient(180deg, #8fbc1e 0%, #7aaa18 100%)'; btn.style.transform = 'scale(0.95)'; btn.style.boxShadow = '0 0 20px rgba(143, 188, 30, 0.8)'; btn.textContent = '‚è≥ Applying...'; btn.disabled = true; setTimeout(() => { applyFireCorrectionUI(); }, 150);" style="width: 100%; padding: 10px; margin-top: 5px; background: linear-gradient(180deg, #6b8e23 0%, #5a7a1c 100%); border: 1px solid #8fbc1e; border-radius: 4px; color: white; font-weight: 600; cursor: pointer; font-size: 13px; transition: all 0.15s ease;">
                                    Apply Fire Correction
                                </button>
                            </div>
                        </div>
                        
                        ${solutions.length > 1 ? `
                        <button class="btn-press" onclick="toggleAlternativeMissions()" id="toggleAltBtn" style="width: 100%; padding: 10px; margin-top: 20px; background: linear-gradient(180deg, #555 0%, #444 100%); border: 1px solid #666; border-radius: 4px; color: #c8d4a0; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ‚ñº Show ${solutions.length - 1} Alternative Mission${solutions.length > 2 ? 's' : ''}
                        </button>
                        ` : ''}
                        
                        ${alternativeMissionsHTML}
                    `;
                    
                    // Clear previous charge and correction state after output is complete
                    window.previousCharge = null;
                    window.originalTargetPos = null;
                    
                    // Store original optimal charge for marking
                    window.originalOptimalCharge = solutions[0].charge;
                    
                    // Initialize selected charge to optimal (first) solution and show correction widget
                    window.selectedCharge = solutions[0].charge;
                    
                    // Auto-select optimal mission to show correction widget immediately
                    setTimeout(() => {
                        selectMission(solutions[0].charge);
                    }, 50);
                } else {
                    const solution = solutions[0];
                    output.classList.add('error');
                    output.innerHTML = `
                        <h2>‚ùå Target Out of Range</h2>
                        <p><strong>Error:</strong> ${solution.error}</p>
                        ${solution.minRange && solution.maxRange ? `
                            <p>
                                <strong>Valid range for this configuration:</strong><br>
                                ${solution.minRange}m - ${solution.maxRange}m
                            </p>
                        ` : ''}
                        <p style="margin-top: 15px;">
                            <strong>Suggestions:</strong>
                        </p>
                        <ul>
                            <li>Try a different mortar type or shell type</li>
                            <li>Move mortar or target positions closer/further</li>
                        </ul>
                    `;
                }
            } catch (error) {
                showOutputError('Calculation Error', error.message + '<br>Check your input values and try again.');
                console.error('Calculation error:', error);
            }
        }
        
        // Initialize on page load
        init();
    </script>
</body>
</html>
