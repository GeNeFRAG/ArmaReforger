<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Primary Meta Tags -->
    <title>Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions</title>
    <meta name="title" content="Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions">
    <meta name="description" content="Free online ballistic calculator for Arma Reforger. Calculate precise firing missions with grid coordinates, elevation, azimuth, fire for effect and time of flight. Supports US 60mm and Russian 82mm mortars in the moment.">
    <meta name="keywords" content="arma reforger, mortar calculator, firing missons, ballistics, grid coordinates, artillery calculator, mil system, US mortar, Russian mortar, game tool">
    <meta name="author" content="ArmaMortars.org">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://armamortars.org/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://armamortars.org/">
    <meta property="og:title" content="Arma Reforger Military Ballistic Calculator for planning Mortar Fire Missions">
    <meta property="og:description" content="Free online mortar calculator for Arma Reforger. Calculate precise firing missions with grid coordinates, elevation, azimuth, fire for effect and time of flight.">
    <meta property="og:image" content="https://armamortars.org/icon.png">
    <meta property="og:site_name" content="ArmaMortars.org">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://armamortars.org/">
    <meta name="twitter:title" content="Arma Reforger Ballistic Calculator">
    <meta name="twitter:description" content="Free online ballistic calculator for Arma Reforger. Calculate precise mortar firing missons in Arma Reforger with grid coordinates.">
    <meta name="twitter:image" content="https://armamortars.org/icon.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#6b8e23">
    
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Arma Reforger Ballistic Calculator",
      "url": "https://armamortars.org/",
      "description": "Calculate precise firing missons for Arma Reforger Mortar Weapon Systems with grid coordinates, elevation, ballistics data, fire corrections and fire for effect patterns.",
      "applicationCategory": "GameApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "150"
      }
    }
    </script>
    
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1f1e 0%, #2a3532 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #6b8e23;
        }
        .logo {
            width: 80px;
            height: auto;
            filter: brightness(0) invert(1) drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }
        h1 {
            color: #c8d4a0;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 1.8em;
            text-align: center;
        }
        h2 {
            color: #b8c7a0;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 25px;
            margin-bottom: 15px;
            border-left: 4px solid #6b8e23;
            padding-left: 12px;
        }
        .container {
            background: rgba(35, 45, 42, 0.85);
            padding: 25px;
            border-radius: 4px;
            border: 1px solid #3a4a45;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            color: #b8c7a0;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #4a5a52;
            border-radius: 2px;
            font-size: 14px;
            background: #2a3532;
            color: #e8e8e8;
            transition: border-color 0.2s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #6b8e23;
            background: #323e3a;
        }
        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        button {
            background: linear-gradient(180deg, #7a9f35 0%, #6b8e23 100%);
            color: white;
            padding: 14px 30px;
            border: 1px solid #5a7e1f;
            border-radius: 2px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        button:hover {
            background: linear-gradient(180deg, #8ab040 0%, #7a9f35 100%);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        button:active {
            transform: translateY(1px);
        }
        button:disabled {
            background: #4a5550;
            border-color: #3a4540;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .result {
            background: rgba(35, 45, 42, 0.9);
            padding: 20px;
            margin-top: 20px;
            border-radius: 4px;
            display: none;
            border: 1px solid #3a4a45;
        }
        .result.active {
            display: block;
        }
        .result.success {
            background: rgba(35, 45, 42, 0.85);
            border: 2px solid #6b8e23;
        }
        .result.error {
            background: rgba(35, 45, 42, 0.85);
            border: 2px solid #a85050;
        }
        .result h2 {
            margin-top: 0;
            color: #d8e4b0;
        }
        .solution-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        .solution-item {
            background: rgba(20, 25, 22, 0.8);
            padding: 14px;
            border-radius: 2px;
            border: 1px solid #4a5a52;
        }
        .solution-item strong {
            display: block;
            color: #a8b898;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .solution-item .value {
            font-size: 22px;
            color: #e8f4d0;
            font-weight: bold;
        }
        .info {
            background: rgba(60, 80, 95, 0.3);
            border: 1px solid #4a6a75;
            padding: 12px;
            border-radius: 2px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #b8c8d0;
        }
        #loading {
            text-align: center;
            padding: 40px 20px;
            color: #95a585;
            font-size: 16px;
        }
        .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(107, 142, 35, 0.1);
            border-radius: 8px;
        }
        .toggle-buttons {
            display: flex;
            gap: 10px;
        }
        .toggle-option {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 14px;
            flex: 1;
            text-align: center;
            white-space: nowrap;
        }
        .toggle-option.active {
            background: #6b8e23;
            border-color: #8fbc1e;
            box-shadow: 0 2px 8px rgba(107, 142, 35, 0.4);
        }
        .toggle-option:hover:not(.active) {
            background: rgba(255, 255, 255, 0.15);
        }
        .coord-mode {
            display: none;
        }
        .coord-mode.active {
            display: block;
        }
        @media (max-width: 600px) {
            .row {
                grid-template-columns: 1fr;
            }
            .solution-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Main Header -->
    <header class="header">
        <img src="https://vectorseek.com/wp-content/uploads/2023/07/Arma-Reforger-Logo-Vector.svg-.png" alt="Arma Reforger Logo - Mortar Calculator" class="logo">
        <h1>ARMA REFORGER Ballistic Mission Planner</h1>
    </header>
    
    <!-- Main Content -->
    <main>
    <div id="loading" role="status" aria-live="polite">Loading ballistic data...</div>
    
    <div id="app" style="display: none;">
        <div class="info">
            ‚ÑπÔ∏è Enter weapon system and target coordinates to calculate firing mission. Mortar charge is automatically selected for optimal range.
        </div>
        
        <div class="toggle-container">
            <span style="font-weight: 500; color: #b8c7a0; text-align: center;">Coordinate Input:</span>
            <div class="toggle-buttons">
                <div class="toggle-option active" onclick="setCoordMode('grid')" id="toggleGrid">
                    üéØ Grid (047/069)
                </div>
                <div class="toggle-option" onclick="setCoordMode('meters')" id="toggleMeters">
                    üìè Meters (X/Y)
                </div>
            </div>
        </div>
        
        <div class="container">
            <h2>1Ô∏è‚É£ Weapon System and Ammunition</h2>
            
            <div class="row">
                <div class="form-group">
                    <label for="mortarType">Weapon System Type</label>
                    <select id="mortarType">
                        <!-- Populated dynamically from ballistic-data.json -->
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="shellType">Ammunition Type</label>
                    <select id="shellType">
                        <!-- Populated dynamically from ballistic-data.json -->
                    </select>
                </div>
            </div>
            
            <h2>2Ô∏è‚É£ Weapon Position</h2>
                
                <!-- Grid Mode -->
                <div id="mortarGridMode" class="coord-mode active">
                    <div class="form-group">
                        <label for="mortarGrid">Grid Coordinates</label>
                        <input type="text" id="mortarGrid" placeholder="047/069 or 0475/0695" style="font-family: monospace; font-size: 16px;">
                        <small style="color: #999; display: block; margin-top: 5px;">3-digit (10m squares) or 4-digit (1m precision)</small>
                    </div>
                </div>
                
                <!-- Meters Mode -->
                <div id="mortarMetersMode" class="coord-mode">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="mortarX">X Coordinate (meters)</label>
                                <input type="number" id="mortarX" placeholder="4800" step="0.1">
                            </div>
                            <div class="form-group">
                                <label for="mortarY">Y Coordinate (meters)</label>
                                <input type="number" id="mortarY" placeholder="7049" step="0.1">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">Enter map coordinates in meters</small>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="mortarZ">Height (m ASL)</label>
                    <input type="number" id="mortarZ" placeholder="168" step="0.1">
                </div>
                
                <h2>Target Position</h2>
                
                <!-- Grid Mode -->
                <div id="targetGridMode" class="coord-mode active">
                    <div class="form-group">
                        <label for="targetGrid">Grid Coordinates</label>
                        <input type="text" id="targetGrid" placeholder="085/105 or 0850/1050" style="font-family: monospace; font-size: 16px;">
                        <small style="color: #999; display: block; margin-top: 5px;">3-digit (10m squares) or 4-digit (1m precision)</small>
                    </div>
                </div>
                
                <!-- Meters Mode -->
                <div id="targetMetersMode" class="coord-mode">
                    <div class="form-group">
                        <div class="row">
                            <div class="form-group">
                                <label for="targetX">X Coordinate (meters)</label>
                                <input type="number" id="targetX" placeholder="4696" step="0.1">
                            </div>
                            <div class="form-group">
                                <label for="targetY">Y Coordinate (meters)</label>
                                <input type="number" id="targetY" placeholder="5516" step="0.1">
                            </div>
                        </div>
                        <small style="color: #999; display: block; margin-top: -15px;">Enter map coordinates in meters</small>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="targetZ">Height (m ASL)</label>
                    <input type="number" id="targetZ" placeholder="64" step="0.1">
                </div>
                
                <div class="info" style="margin-top: 15px;">
                    üìç Range, Azimuth, and Height Difference will be computed automatically from coordinates
                </div>
            
            <h2>3Ô∏è‚É£ Fire for Effect (Optional)</h2>
            
            <div class="info" style="margin-bottom: 15px;">
                üéØ Engage area targets with multiple rounds. <strong>Lateral sheaf</strong> for width coverage, <strong>linear sheaf</strong> for depth penetration, <strong>circular pattern</strong> for 360¬∞ area saturation. <strong>Uses corrected target coordinates if applied.</strong>
            </div>
            
            <div class="row">
                <div class="form-group">
                    <label for="ffeEnabled">
                        <input type="checkbox" id="ffeEnabled" style="margin-right: 8px; width: auto; height: auto;">
                        Enable Fire for Effect
                    </label>
                </div>
            </div>
            
            <div id="ffeControls" style="display: none;">
                <div class="row">
                    <div class="form-group">
                        <label for="ffePattern">Sheaf Type</label>
                        <select id="ffePattern">
                            <option value="perpendicular">Lateral Sheaf (Width Coverage)</option>
                            <option value="along-bearing">Linear Sheaf (Depth Penetration)</option>
                            <option value="circular">Circular Pattern (Area Saturation)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="ffeRounds">Rounds per Salvo</label>
                        <select id="ffeRounds">
                            <option value="3">3 Rounds</option>
                            <option value="5" selected>5 Rounds</option>
                            <option value="6">6 Rounds</option>
                            <option value="8">8 Rounds</option>
                            <option value="9">9 Rounds</option>
                            <option value="12">12 Rounds</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group" id="ffeSpacingGroup">
                    <label for="ffeSpacing">Round Interval (meters)</label>
                    <input type="number" id="ffeSpacing" placeholder="50" value="50" min="10" max="200" step="10">
                    <small style="color: #999; display: block; margin-top: 5px;">Spacing between rounds (10-200m)</small>
                </div>
                
                <div class="form-group" id="ffeRadiusGroup" style="display: none;">
                    <label for="ffeRadius">Circle Radius (meters)</label>
                    <input type="number" id="ffeRadius" placeholder="100" value="100" min="20" max="300" step="10">
                    <small style="color: #999; display: block; margin-top: 5px;">Distance from center to impact points (20-300m)</small>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="calculate" style="flex: 3; transition: transform 0.1s ease, box-shadow 0.1s ease;" onmousedown="this.style.transform='scale(0.95)'; this.style.boxShadow='0 0 20px rgba(143, 188, 30, 0.8)';" onmouseup="this.style.transform='scale(1)'; this.style.boxShadow='none';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';">Compute Fire Mission</button>
                <button id="reset" style="flex: 1; background: linear-gradient(180deg, #666 0%, #555 100%); transition: transform 0.1s ease, box-shadow 0.1s ease;" onmousedown="this.style.transform='scale(0.95)'; this.style.boxShadow='0 0 20px rgba(255, 107, 107, 0.6)';" onmouseup="this.style.transform='scale(1)'; this.style.boxShadow='none';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';">Reset</button>
            </div>
        </div>
        
        <div id="output" class="result"></div>
    </div>
    </main>
    
    <!-- Footer -->
    <footer style="text-align: center; padding: 20px; margin-top: 40px; color: #95a585; font-size: 12px; border-top: 1px solid #3a4a45;">
        <p>¬© 2025 ArmaMortars.org | Free Arma Reforger Mortar Calculator <span style="color: #6b7a65;">v1.3.8</span></p>
        <p>Accurate ballistic calculations for US 60mm & Russian 82mm mortars | Grid coordinate support</p>
        <p>
            <a href="https://github.com/GeNeFRAG/ArmaReforger/tree/main/mortar_core/" target="_blank" rel="noopener noreferrer" style="color: #8fbc1e; text-decoration: none;">‚≠ê View on GitHub</a>
            | 
            <a href="https://github.com/GeNeFRAG/ArmaReforger/blob/main/LICENSE" target="_blank" rel="noopener noreferrer" style="color: #8fbc1e; text-decoration: none;">üìÑ MIT License</a>
        </p>
    </footer>
    
    <script src="MortarCalculator.js?v=1.3.8"></script>
    <script>
        let ballisticDataLoaded = false;
        
        // Toggle between grid and meters coordinate input
        function setCoordMode(mode) {
            const gridModes = document.querySelectorAll('#mortarGridMode, #targetGridMode');
            const meterModes = document.querySelectorAll('#mortarMetersMode, #targetMetersMode');
            const toggleGrid = document.getElementById('toggleGrid');
            const toggleMeters = document.getElementById('toggleMeters');
            
            if (mode === 'grid') {
                gridModes.forEach(el => el.classList.add('active'));
                meterModes.forEach(el => el.classList.remove('active'));
                toggleGrid.classList.add('active');
                toggleMeters.classList.remove('active');
            } else {
                gridModes.forEach(el => el.classList.remove('active'));
                meterModes.forEach(el => el.classList.add('active'));
                toggleGrid.classList.remove('active');
                toggleMeters.classList.add('active');
            }
            
            // Clear all input fields
            document.getElementById('mortarGrid').value = '';
            document.getElementById('mortarX').value = '';
            document.getElementById('mortarY').value = '';
            document.getElementById('mortarZ').value = '';
            document.getElementById('targetGrid').value = '';
            document.getElementById('targetX').value = '';
            document.getElementById('targetY').value = '';
            document.getElementById('targetZ').value = '';
            
            // Clear red highlighting
            document.getElementById('targetGrid').style.color = '';
            document.getElementById('targetX').style.color = '';
            document.getElementById('targetY').style.color = '';
            
            // Reset correction flag
            window.correctionApplied = false;
            
            // Reset Fire for Effect
            document.getElementById('ffeEnabled').checked = false;
            document.getElementById('ffeControls').style.display = 'none';
            document.getElementById('ffePattern').value = 'perpendicular';
            document.getElementById('ffeRounds').value = '5';
            document.getElementById('ffeSpacing').value = '50';
            document.getElementById('ffeRadius').value = '100';
            document.getElementById('ffeSpacingGroup').style.display = 'block';
            document.getElementById('ffeRadiusGroup').style.display = 'none';
            
            // Clear output
            const output = document.getElementById('output');
            output.innerHTML = '';
            output.className = 'result';
        }
        
        // Update correction preview to show doctrinal terms
        function updateCorrectionPreview() {
            const correctionLRInput = document.getElementById('correctionLR');
            const correctionADInput = document.getElementById('correctionAD');
            const correctionPreview = document.getElementById('correctionPreview');
            const correctionText = document.getElementById('correctionText');
            
            const lr = parseFloat(correctionLRInput.value) || 0;
            const ad = parseFloat(correctionADInput.value) || 0;
            
            if (lr === 0 && ad === 0) {
                correctionPreview.style.display = 'none';
                return;
            }
            
            const lrText = lr === 0 ? '' : (lr > 0 ? `Right ${Math.abs(lr)}` : `Left ${Math.abs(lr)}`);
            const adText = ad === 0 ? '' : (ad > 0 ? `Add ${Math.abs(ad)}` : `Drop ${Math.abs(ad)}`);
            
            let resultText = '';
            if (lrText && adText) {
                resultText = `${lrText}, ${adText}`;
            } else if (lrText) {
                resultText = lrText;
            } else if (adText) {
                resultText = adText;
            }
            
            correctionText.textContent = resultText;
            correctionPreview.style.display = 'block';
        }
        
        // Apply fire correction to target position
        function applyFireCorrectionUI() {
            const correctionLR = parseFloat(document.getElementById('correctionLR').value) || 0;
            const correctionAD = parseFloat(document.getElementById('correctionAD').value) || 0;
            
            if (correctionLR === 0 && correctionAD === 0) {
                return;
            }
            
            try {
                // Parse mortar position
                let mortarPos;
                const mortarGrid = document.getElementById('mortarGrid').value.trim();
                if (mortarGrid) {
                    const mortarZ = parseFloat(document.getElementById('mortarZ').value) || 0;
                    mortarPos = MortarCalculator.parsePosition({ grid: mortarGrid, z: mortarZ });
                } else {
                    const mortarX = parseFloat(document.getElementById('mortarX').value);
                    const mortarY = parseFloat(document.getElementById('mortarY').value);
                    const mortarZ = parseFloat(document.getElementById('mortarZ').value) || 0;
                    if (isNaN(mortarX) || isNaN(mortarY)) {
                        throw new Error('Enter mortar position first');
                    }
                    mortarPos = { x: mortarX, y: mortarY, z: mortarZ };
                }
                
                // Parse target position
                let targetPos;
                const targetGrid = document.getElementById('targetGrid').value.trim();
                if (targetGrid) {
                    const targetZ = parseFloat(document.getElementById('targetZ').value) || 0;
                    targetPos = MortarCalculator.parsePosition({ grid: targetGrid, z: targetZ });
                } else {
                    const targetX = parseFloat(document.getElementById('targetX').value);
                    const targetY = parseFloat(document.getElementById('targetY').value);
                    const targetZ = parseFloat(document.getElementById('targetZ').value) || 0;
                    if (isNaN(targetX) || isNaN(targetY)) {
                        throw new Error('Enter target position first');
                    }
                    targetPos = { x: targetX, y: targetY, z: targetZ };
                }
                
                // Apply fire correction
                const corrected = MortarCalculator.applyFireCorrection(mortarPos, targetPos, correctionLR, correctionAD);
                
                // Update target fields with corrected position and highlight in red
                const targetXInput = document.getElementById('targetX');
                const targetYInput = document.getElementById('targetY');
                const targetGridInput = document.getElementById('targetGrid');
                
                targetXInput.value = corrected.x.toFixed(1);
                targetYInput.value = corrected.y.toFixed(1);
                targetXInput.style.color = '#ff6b6b';
                targetYInput.style.color = '#ff6b6b';
                
                // Convert to grid if in grid mode
                const gridMode = document.getElementById('targetGridMode').classList.contains('active');
                if (gridMode) {
                    const gridCoords = MortarCalculator.metersToGrid(corrected.x, corrected.y, true);
                    targetGridInput.value = gridCoords;
                    targetGridInput.style.color = '#ff6b6b';
                }
                
                // Store previous charge before recalculation
                window.previousCharge = window.selectedCharge || (window.lastSolution ? window.lastSolution.charge : null);
                
                // Mark that correction was applied (for highlighting output)
                window.correctionApplied = true;
                
                // Automatically recalculate firing mission with SELECTED CHARGE
                calculateSolution();
                
            } catch (error) {
                console.error('Correction error:', error);
                const output = document.getElementById('output');
                output.className = 'result active error';
                output.innerHTML = `
                    <h2>‚ùå Correction Error</h2>
                    <p><strong>Error:</strong> ${error.message}</p>
                `;
            }
        }
        
        // Get all available mortar types from loaded ballistic data
        function getAllMortarTypes() {
            try {
                return MortarCalculator.getAllMortarTypes();
            } catch (error) {
                console.warn('Could not get mortar types:', error);
                return [];
            }
        }
        
        // Get available shell types for a mortar from loaded ballistic data
        function getShellTypesForMortar(mortarId) {
            try {
                const config = MortarCalculator.getWeaponConfig(mortarId, 'HE');
                const mortar = config.mortar;
                
                return mortar.shellTypes.map(shell => ({
                    value: shell.type,
                    label: shell.name
                }));
            } catch (error) {
                console.warn('Could not get shell types:', error);
                return [];
            }
        }
        
        // Update mortar type options from ballistic data
        function updateMortarTypes() {
            const mortarTypeSelect = document.getElementById('mortarType');
            const currentValue = mortarTypeSelect.value;
            
            const availableMortars = getAllMortarTypes();
            
            // Sort: US mortars first, then others
            availableMortars.sort((a, b) => {
                const aIsUS = a.id === 'US' || a.id.startsWith('US_');
                const bIsUS = b.id === 'US' || b.id.startsWith('US_');
                if (aIsUS && !bIsUS) return -1;
                if (!aIsUS && bIsUS) return 1;
                return a.name.localeCompare(b.name);
            });
            
            mortarTypeSelect.innerHTML = '';
            availableMortars.forEach(mortar => {
                const option = document.createElement('option');
                option.value = mortar.id;
                option.textContent = `${mortar.name}`;
                mortarTypeSelect.appendChild(option);
            });
            
            // Restore previous selection if available, otherwise select US mortar
            const optionExists = availableMortars.some(m => m.id === currentValue);
            if (optionExists) {
                mortarTypeSelect.value = currentValue;
            } else if (availableMortars.length > 0) {
                const usMortar = availableMortars.find(m => m.id === 'US' || m.id.startsWith('US_'));
                mortarTypeSelect.value = usMortar ? usMortar.id : availableMortars[0].id;
            }
        }
        
        // Update shell type options based on mortar type
        function updateShellTypes() {
            const mortarType = document.getElementById('mortarType').value;
            const shellTypeSelect = document.getElementById('shellType');
            const currentValue = shellTypeSelect.value;
            
            const availableShells = getShellTypesForMortar(mortarType);
            
            shellTypeSelect.innerHTML = '';
            availableShells.forEach(shell => {
                const option = document.createElement('option');
                option.value = shell.value;
                option.textContent = shell.label;
                shellTypeSelect.appendChild(option);
            });
            
            // Restore previous selection if available, otherwise select first
            const optionExists = availableShells.some(s => s.value === currentValue);
            if (optionExists) {
                shellTypeSelect.value = currentValue;
            } else if (availableShells.length > 0) {
                shellTypeSelect.value = availableShells[0].value;
            }
        }
        
        // Load ballistic data on page load
        async function init() {
            const loading = document.getElementById('loading');
            const app = document.getElementById('app');
            
            try {
                await MortarCalculator.loadBallisticData('ballistic-data.json');
                ballisticDataLoaded = true;
                
                loading.style.display = 'none';
                app.style.display = 'block';
                
                // Initialize mortar types and shell types after data is loaded
                updateMortarTypes();
                updateShellTypes();
                
                console.log('‚úÖ Ballistic data loaded successfully');
            } catch (error) {
                loading.innerHTML = `
                    <div style="color: red;">
                        ‚ùå Error loading ballistic data: ${error.message}
                        <br>Make sure the HTTP server is running from the mortar_core directory.
                    </div>
                `;
                console.error('Error loading ballistic data:', error);
            }
        }
        
        // Setup event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const calculateBtn = document.getElementById('calculate');
            const mortarTypeSelect = document.getElementById('mortarType');
            
            // Update shell types when mortar type changes
            mortarTypeSelect.addEventListener('change', updateShellTypes);
            
            calculateBtn.addEventListener('click', calculateSolution);
            
            // Fire for Effect toggle
            const ffeEnabled = document.getElementById('ffeEnabled');
            const ffeControls = document.getElementById('ffeControls');
            ffeEnabled.addEventListener('change', function() {
                ffeControls.style.display = this.checked ? 'block' : 'none';
                
                // Recalculate when FFE is toggled
                const output = document.getElementById('output');
                if (output.classList.contains('active')) {
                    calculateSolution();
                }
            });
            
            // Fire for Effect pattern type change
            const ffePattern = document.getElementById('ffePattern');
            const ffeSpacingGroup = document.getElementById('ffeSpacingGroup');
            const ffeRadiusGroup = document.getElementById('ffeRadiusGroup');
            ffePattern.addEventListener('change', function() {
                if (this.value === 'circular') {
                    ffeSpacingGroup.style.display = 'none';
                    ffeRadiusGroup.style.display = 'block';
                } else {
                    ffeSpacingGroup.style.display = 'block';
                    ffeRadiusGroup.style.display = 'none';
                }
            });
            
            // Reset button
            const resetBtn = document.getElementById('reset');
            resetBtn.addEventListener('click', function() {
                // Clear all input fields
                document.getElementById('mortarGrid').value = '';
                document.getElementById('mortarX').value = '';
                document.getElementById('mortarY').value = '';
                document.getElementById('mortarZ').value = '';
                document.getElementById('targetGrid').value = '';
                document.getElementById('targetX').value = '';
                document.getElementById('targetY').value = '';
                document.getElementById('targetZ').value = '';
                
                // Clear red highlighting from corrected fields
                document.getElementById('targetGrid').style.color = '';
                document.getElementById('targetX').style.color = '';
                document.getElementById('targetY').style.color = '';
                
                // Reset correction flag
                window.correctionApplied = false;
                
                // Reset Fire for Effect
                document.getElementById('ffeEnabled').checked = false;
                document.getElementById('ffeControls').style.display = 'none';
                document.getElementById('ffePattern').value = 'perpendicular';
                document.getElementById('ffeRounds').value = '5';
                document.getElementById('ffeSpacing').value = '50';
                document.getElementById('ffeRadius').value = '100';
                document.getElementById('ffeSpacingGroup').style.display = 'block';
                document.getElementById('ffeRadiusGroup').style.display = 'none';
                
                // Clear output and remove error class
                const output = document.getElementById('output');
                output.innerHTML = '';
                output.className = 'result';
            });
            
            // Clear red highlighting when user manually edits target fields
            ['targetGrid', 'targetX', 'targetY'].forEach(id => {
                document.getElementById(id).addEventListener('input', function() {
                    this.style.color = '';
                    window.correctionApplied = false;
                });
            });
            
            // Allow Enter key to trigger calculation
            document.querySelectorAll('input').forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') calculateSolution();
                });
            });
            
            // Setup event delegation for dynamically created correction controls
            document.addEventListener('input', function(e) {
                if (e.target.id === 'correctionLR' || e.target.id === 'correctionAD') {
                    updateCorrectionPreview();
                }
            });
        });
        
        // Toggle visibility of alternative fire missions
        function toggleAlternativeMissions() {
            const altMissions = document.querySelectorAll('.alternativeMission');
            const btn = document.getElementById('toggleAltBtn');
            const isHidden = altMissions[0] && altMissions[0].style.display === 'none';
            
            altMissions.forEach(mission => {
                mission.style.display = isHidden ? 'block' : 'none';
            });
            
            if (btn) {
                btn.textContent = isHidden 
                    ? `‚ñ≤ Hide Alternative Mission${altMissions.length > 1 ? 's' : ''}`
                    : `‚ñº Show ${altMissions.length} Alternative Mission${altMissions.length > 1 ? 's' : ''}`;
            }
        }
        
        // Select a specific fire mission for correction
        function selectMission(charge) {
            window.selectedCharge = charge;
            
            // Store the original optimal charge if not already stored
            if (window.originalOptimalCharge === undefined && window.lastSolutions && window.lastSolutions.length > 0) {
                window.originalOptimalCharge = window.lastSolutions[0].charge;
            }
            
            // Find the correction widget and all mission elements
            const correctionWidget = document.getElementById('fireCorrectionWidget');
            const selectedBtn = document.getElementById(`selectBtn_${charge}`);
            
            if (correctionWidget && selectedBtn) {
                // Find the selected mission card
                const selectedCard = selectedBtn.closest('div[style*="background"]');
                
                if (selectedCard && selectedCard.parentNode) {
                    // Get all solution cards
                    const solutions = window.lastSolutions || [];
                    const allCards = [];
                    
                    solutions.forEach(sol => {
                        const btn = document.getElementById(`selectBtn_${sol.charge}`);
                        if (btn) {
                            const card = btn.closest('div[style*="background"]');
                            if (card) {
                                allCards.push({ charge: sol.charge, card: card });
                            }
                        }
                    });
                    
                    // Find the parent container
                    const container = selectedCard.parentNode;
                    
                    // Store the toggle button and alternative missions
                    const toggleBtn = document.getElementById('toggleAltBtn');
                    
                    // Remove all mission cards temporarily
                    allCards.forEach(item => {
                        if (item.card.parentNode) {
                            item.card.remove();
                        }
                    });
                    
                    // Remove toggle button and correction widget temporarily
                    if (correctionWidget.parentNode) correctionWidget.remove();
                    if (toggleBtn && toggleBtn.parentNode) toggleBtn.remove();
                    
                    // Find the selected card object
                    const selectedCardObj = allCards.find(item => item.charge === charge);
                    const otherCards = allCards.filter(item => item.charge !== charge);
                    
                    // Re-insert in new order
                    if (selectedCardObj) {
                        // Insert selected mission first (make it optimal)
                        container.appendChild(selectedCardObj.card);
                        selectedCardObj.card.style.display = 'block';
                        selectedCardObj.card.removeAttribute('id');
                        selectedCardObj.card.classList.remove('alternativeMission');
                        
                        // Update styling to optimal
                        selectedCardObj.card.style.background = 'rgba(40, 55, 45, 0.9)';
                        selectedCardObj.card.style.border = '2px solid #6b8e23';
                        
                        // Update title in the selected card
                        const title = selectedCardObj.card.querySelector('h3');
                        if (title) {
                            title.innerHTML = `üéØ Optimal Fire Mission - Charge ${charge}`;
                        }
                        
                        // Insert correction widget
                        container.appendChild(correctionWidget);
                        correctionWidget.style.display = 'block';
                        
                        // Insert toggle button if there are alternatives
                        if (otherCards.length > 0 && toggleBtn) {
                            container.appendChild(toggleBtn);
                            toggleBtn.textContent = `‚ñº Show ${otherCards.length} Alternative Mission${otherCards.length > 1 ? 's' : ''}`;
                        }
                        
                        // Insert other missions as alternatives (hidden)
                        otherCards.forEach((item, index) => {
                            item.card.id = `altMission_${index + 1}`;
                            item.card.classList.add('alternativeMission');
                            item.card.style.display = 'none';
                            item.card.style.background = 'rgba(35, 45, 42, 0.7)';
                            item.card.style.border = '1px solid #4a5a52';
                            
                            // Mark the original optimal charge
                            const title = item.card.querySelector('h3');
                            if (title && item.charge === window.originalOptimalCharge) {
                                title.innerHTML = `‚≠ê Alternative Fire Mission - Charge ${item.charge} <span style="color: #ffd700; font-size: 11px;">(Original Optimal)</span>`;
                            } else if (title) {
                                title.innerHTML = `üîÑ Alternative Fire Mission - Charge ${item.charge}`;
                            }
                            
                            container.appendChild(item.card);
                        });
                    }
                }
            }
            
            // Update all buttons
            const solutions = window.lastSolutions || [];
            solutions.forEach(sol => {
                const btn = document.getElementById(`selectBtn_${sol.charge}`);
                if (btn) {
                    if (sol.charge === charge) {
                        btn.style.background = 'linear-gradient(180deg, #6b8e23 0%, #5a7a1c 100%)';
                        btn.style.borderColor = '#8fbc1e';
                        btn.textContent = '‚úì Selected Mission';
                    } else {
                        btn.style.background = 'linear-gradient(180deg, #555 0%, #444 100%)';
                        btn.style.borderColor = '#666';
                        btn.textContent = 'Use This Mission';
                    }
                }
            });
            
            // Update correction widget header
            const chargeDisplay = document.getElementById('selectedChargeDisplay');
            if (chargeDisplay) {
                chargeDisplay.textContent = `(Charge ${charge})`;
            }
        }
        
        function calculateSolution() {
            if (!ballisticDataLoaded) {
                return;
            }
            
            const output = document.getElementById('output');
            
            // Clear previous results
            output.className = 'result';
            output.innerHTML = '';
            
            try {
                const mortarId = document.getElementById('mortarType').value;
                const shellType = document.getElementById('shellType').value;
                
                // Parse mortar position
                let mortarPos;
                const mortarGrid = document.getElementById('mortarGrid').value.trim();
                if (mortarGrid) {
                    const mortarZ = parseFloat(document.getElementById('mortarZ').value) || 0;
                    mortarPos = { grid: mortarGrid, z: mortarZ };
                } else {
                    const mortarX = parseFloat(document.getElementById('mortarX').value);
                    const mortarY = parseFloat(document.getElementById('mortarY').value);
                    const mortarZ = parseFloat(document.getElementById('mortarZ').value) || 0;
                    if (isNaN(mortarX) || isNaN(mortarY)) {
                        throw new Error('Enter either grid coordinates or X/Y meter values for mortar');
                    }
                    mortarPos = { x: mortarX, y: mortarY, z: mortarZ };
                }
                
                // Parse target position
                let targetPos;
                const targetGrid = document.getElementById('targetGrid').value.trim();
                if (targetGrid) {
                    const targetZ = parseFloat(document.getElementById('targetZ').value) || 0;
                    targetPos = { grid: targetGrid, z: targetZ };
                } else {
                    const targetX = parseFloat(document.getElementById('targetX').value);
                    const targetY = parseFloat(document.getElementById('targetY').value);
                    const targetZ = parseFloat(document.getElementById('targetZ').value) || 0;
                    if (isNaN(targetX) || isNaN(targetY)) {
                        throw new Error('Enter either grid coordinates or X/Y meter values for target');
                    }
                    targetPos = { x: targetX, y: targetY, z: targetZ };
                }
                
                // Check if Fire for Effect is enabled
                const ffeEnabled = document.getElementById('ffeEnabled').checked;
                
                if (ffeEnabled) {
                    // Fire for Effect mode
                    const ffePattern = document.getElementById('ffePattern').value;
                    const ffeRounds = parseInt(document.getElementById('ffeRounds').value);
                    
                    // Parse mortar and target positions to ensure they're in {x,y,z} format
                    const mortarParsed = MortarCalculator.parsePosition(mortarPos);
                    const targetParsed = MortarCalculator.parsePosition(targetPos);
                    
                    console.log('üéØ FFE Using Coordinates:');
                    console.log('  Target Position (input):', targetPos);
                    console.log('  Target Position (parsed):', targetParsed);
                    console.log('  Correction Applied:', window.correctionApplied ? 'YES (red coordinates)' : 'NO (original coordinates)');
                    
                    // Generate pattern positions based on pattern type
                    let targetPositions;
                    let patternParam;
                    
                    if (ffePattern === 'circular') {
                        const ffeRadius = parseFloat(document.getElementById('ffeRadius').value) || 100;
                        targetPositions = MortarCalculator.generateCircularPattern(
                            targetParsed,
                            ffeRadius,
                            ffeRounds
                        );
                        patternParam = ffeRadius;
                    } else {
                        const ffeSpacing = parseFloat(document.getElementById('ffeSpacing').value) || 50;
                        targetPositions = MortarCalculator.generateFireForEffectPattern(
                            mortarParsed,
                            targetParsed,
                            ffePattern,
                            ffeRounds,
                            ffeSpacing
                        );
                        patternParam = ffeSpacing;
                    }
                    
                    // Calculate solutions for each position using consistent charge
                    const ffeSolutions = [];
                    
                    // First, determine optimal charge from center target
                    const centerInput = MortarCalculator.prepareInput(mortarPos, targetParsed, mortarId, shellType);
                    const centerSolutions = MortarCalculator.calculateAllTrajectories(centerInput);
                    
                    if (centerSolutions.length === 0 || !centerSolutions[0].inRange) {
                        throw new Error('Center target out of range - cannot calculate FFE pattern');
                    }
                    
                    // Use the optimal charge for all FFE rounds
                    const ffeCharge = centerSolutions[0].charge;
                    
                    targetPositions.forEach((pos, index) => {
                        const input = MortarCalculator.prepareInput(mortarPos, pos, mortarId, shellType);
                        // Force the same charge for all FFE rounds
                        input.chargeLevel = ffeCharge;
                        const solutions = MortarCalculator.calculateAllTrajectories(input);
                        if (solutions.length > 0 && solutions[0].inRange) {
                            ffeSolutions.push({
                                roundNumber: index + 1,
                                targetPos: pos,
                                input: input,
                                solution: solutions[0]
                            });
                        }
                    });
                    
                    // Sort by azimuth for easier gun traverse (always same direction)
                    const sortedFFE = MortarCalculator.sortFFESolutionsByAzimuth(ffeSolutions);
                    
                    // Display FFE results
                    if (sortedFFE.length > 0) {
                        output.className = 'result active success';
                        
                        let patternDesc, patternParamDesc;
                        if (ffePattern === 'perpendicular') {
                            patternDesc = 'Lateral Sheaf (Width Coverage)';
                            patternParamDesc = `Round Interval: ${patternParam}m`;
                        } else if (ffePattern === 'along-bearing') {
                            patternDesc = 'Linear Sheaf (Depth Penetration)';
                            patternParamDesc = `Round Interval: ${patternParam}m`;
                        } else {
                            patternDesc = 'Circular Pattern (Area Saturation)';
                            patternParamDesc = `Circle Radius: ${patternParam}m`;
                        }
                        
                        let ffeHTML = `
                            <h2>üí• Fire for Effect Mission</h2>
                            
                            ${window.correctionApplied ? '<div style="background: rgba(255, 107, 107, 0.15); padding: 10px; border-radius: 4px; border: 1px solid rgba(255, 107, 107, 0.3); margin-bottom: 15px; color: #ff9999; font-size: 13px;">üî¥ <strong>Fire correction applied:</strong> Red values include observer correction</div>' : ''}
                            
                            <div style="background: rgba(60, 75, 50, 0.4); padding: 12px; border-radius: 4px; border: 1px solid #6b8e23; margin-bottom: 15px; color: #d8e4b0;">
                                <strong>üìä Sheaf Type:</strong> ${patternDesc}<br>
                                <strong>üéØ Salvo Size:</strong> ${sortedFFE.length} of ${ffeRounds} rounds (in range)<br>
                                <strong>üìè ${patternParamDesc}</strong>
                            </div>
                            
                            <h3 style="font-size: 16px; margin-bottom: 10px;">Fire Mission Commands</h3>
                        `;
                        
                        // Store previous charge for highlighting
                        const previousChargeForDisplay = window.previousCharge;
                        
                        sortedFFE.forEach(({ roundNumber, targetPos, input, solution }) => {
                            ffeHTML += `
                                <div style="background: rgba(35, 45, 42, 0.85); padding: 15px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #4a5a52;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <h3 style="margin: 0; font-size: 16px; color: #c8d4a0;">
                                            Round ${roundNumber} of ${ffeRounds} - Charge ${solution.charge}
                                        </h3>
                                        <span style="font-size: 12px; color: #95a585; font-style: italic;">
                                            Range: ${input.distance.toFixed(1)}m | Alt Diff: ${input.heightDifference > 0 ? '+' : ''}${input.heightDifference.toFixed(1)}m
                                        </span>
                                    </div>
                                    <div class="solution-grid">
                                        <div class="solution-item">
                                            <strong>AZIMUTH</strong>
                                            <div class="value" ${window.correctionApplied ? 'style="color: #ff6b6b"' : ''}>${solution.azimuthMils} mils</div>
                                            <div style="color: ${window.correctionApplied ? '#ff6b6b' : '#95a585'}; font-size: 12px;">(${solution.azimuth}¬∞)</div>
                                        </div>
                                        <div class="solution-item">
                                            <strong>ELEVATION</strong>
                                            <div class="value" ${window.correctionApplied ? 'style="color: #ff6b6b"' : ''}>${solution.elevation} mils</div>
                                            <div style="color: ${window.correctionApplied ? '#ff6b6b' : '#95a585'}; font-size: 12px;">(${solution.elevationDegrees}¬∞)</div>
                                            ${solution.elevationCorrection && solution.elevationCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">dElev: ${solution.dElev} and Elevation Correction: ${solution.elevationCorrection > 0 ? '+' : ''}${solution.elevationCorrection.toFixed(1)} mils</div>` : ''}
                                        </div>
                                        <div class="solution-item">
                                            <strong>CHARGE</strong>
                                            <div class="value" ${typeof previousChargeForDisplay === 'number' && previousChargeForDisplay !== solution.charge ? 'style="color: #ff6b6b"' : ''}>${solution.charge}</div>
                                            ${typeof previousChargeForDisplay === 'number' && previousChargeForDisplay !== solution.charge ? `<div style="color: #ff6b6b; font-size: 11px; margin-top: 2px;">was: ${previousChargeForDisplay}</div>` : ''}
                                        </div>
                                        <div class="solution-item">
                                            <strong>TIME OF FLIGHT</strong>
                                            <div class="value">${solution.timeOfFlight}s</div>
                                            ${solution.tofCorrection && solution.tofCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">Correction: ${solution.tofCorrection > 0 ? '+' : ''}${solution.tofCorrection.toFixed(1)}s (TOF/100m: ${solution.tofPer100m})</div>` : ''}
                                        </div>
                                    </div>
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(20, 25, 22, 0.6); border-radius: 3px; font-size: 12px; color: #a8b898;">
                                        <strong>Charge Range:</strong> ${solution.minRange}m - ${solution.maxRange}m
                                    </div>
                                </div>
                            `;
                        });
                        
                        output.innerHTML = ffeHTML;
                        
                        // Clear previous charge after FFE output is complete
                        window.previousCharge = null;
                    } else {
                        throw new Error('No rounds in range for Fire for Effect pattern');
                    }
                    
                    return; // Exit early, don't run normal calculation
                }
                
                // Use prepareInput to calculate range, azimuth, and height difference
                const input = MortarCalculator.prepareInput(mortarPos, targetPos, mortarId, shellType);
                
                console.log('Mortar Position:', mortarPos);
                console.log('Target Position:', targetPos);
                console.log('Calculated Parameters:', {
                    distance: input.distance.toFixed(1) + 'm',
                    bearing: input.bearing.toFixed(1) + '¬∞',
                    bearingMils: MortarCalculator.degreesToMils(input.bearing) + ' mils',
                    heightDifference: input.heightDifference.toFixed(1) + 'm'
                });
                
                console.log('Input:', input);
                
                // Calculate all trajectory options
                let solutions = MortarCalculator.calculateAllTrajectories(input);
                
                // If correction was applied and a charge was selected, keep that charge as primary
                if (window.correctionApplied && window.selectedCharge !== undefined && solutions.length > 0) {
                    const selectedChargeIdx = solutions.findIndex(s => s.charge === window.selectedCharge);
                    if (selectedChargeIdx > 0) {
                        // Move selected charge to first position (keep as optimal)
                        const selectedSolution = solutions.splice(selectedChargeIdx, 1)[0];
                        solutions.unshift(selectedSolution);
                    }
                }
                
                // Store solutions globally for mission selection
                window.lastSolutions = solutions;
                
                // Store the primary solution for charge change detection
                if (solutions.length > 0 && solutions[0].inRange) {
                    window.lastSolution = solutions[0];
                }
                
                console.log('Solutions:', solutions);
                
                // Generate trajectory data using MortarCalculator
                const trajectoryData = MortarCalculator.generateTrajectoryPoints(solutions, input.distance, input.mortarType);
                
                // Render SVG trajectories
                let trajectorySVG = '';
                if (trajectoryData.series && trajectoryData.series.length > 0) {
                    const svgTop = 30;
                    const groundY = 220;
                    const availablePx = groundY - svgTop;
                    const verticalScale = trajectoryData.globalMaxY > 0 ? availablePx / trajectoryData.globalMaxY : 1;
                    
                    trajectoryData.series.forEach((series, i) => {
                        const { color, elevDeg, points, charge, tof } = series;
                        
                        let svgPoints = points.map(p => {
                            const screenX = 50 + (p.x / trajectoryData.globalRange) * 500;
                            const screenY = groundY - p.y * verticalScale;
                            return screenX.toFixed(1) + ',' + screenY.toFixed(1);
                        });
                        
                        svgPoints[svgPoints.length - 1] = '550,' + groundY;
                        
                        const pathData = 'M ' + svgPoints.join(' L ');
                        const legendY = 30 + i * 25;
                        const textY = 34 + i * 25;
                        
                        trajectorySVG += '<path d="' + pathData + '" fill="none" stroke="' + color + '" stroke-width="2.5" opacity="0.8"/>';
                        trajectorySVG += '<circle cx="300" cy="' + legendY + '" r="4" fill="' + color + '"/>';
                        trajectorySVG += '<text x="310" y="' + textY + '" font-size="11" fill="' + color + '" font-weight="bold">';
                        trajectorySVG += 'Charge ' + charge + ': ' + elevDeg.toFixed(1) + '¬∞ (' + tof + 's)</text>';
                    });
                }
                
                // Display result
                output.className = 'result active';
                
                if (solutions.length > 0 && solutions[0].inRange) {
                    output.classList.add('success');
                    
                    let solutionsHTML = '';
                    
                    // Add correction hint if correction was applied
                    if (window.correctionApplied) {
                        solutionsHTML += '<div style="background: rgba(255, 107, 107, 0.15); padding: 10px; border-radius: 4px; border: 1px solid rgba(255, 107, 107, 0.3); margin-bottom: 15px; color: #ff9999; font-size: 13px;">üî¥ <strong>Fire correction applied:</strong> Red values include observer correction</div>';
                    }
                    
                    // Add charge change warning if charge changed (only if previousCharge is a valid number)
                    if (typeof window.previousCharge === 'number' && window.previousCharge !== solutions[0].charge) {
                        solutionsHTML += `<div style="background: rgba(255, 165, 0, 0.15); padding: 10px; border-radius: 4px; border: 1px solid rgba(255, 165, 0, 0.4); margin-bottom: 15px; color: #ffcc99; font-size: 13px;">‚ö†Ô∏è <strong>Charge changed:</strong> Correction moved target from Charge ${window.previousCharge} to Charge ${solutions[0].charge} (different ballistic trajectory)</div>`;
                    }
                    
                    // Store previous charge for highlighting (before clearing)
                    const previousChargeForDisplay = window.previousCharge;
                    
                    let optimalMissionHTML = '';
                    let alternativeMissionsHTML = '';
                    
                    solutions.forEach((solution, index) => {
                        let trajectoryLabel;
                        if (index === 0) {
                            trajectoryLabel = 'üéØ Optimal Fire Mission';
                        } else {
                            trajectoryLabel = solution.trajectoryType === 'high' 
                                ? 'üîÑ Alternative Fire Mission (High Angle)' 
                                : 'üîÑ Alternative Fire Mission (Low Angle)';
                        }
                        
                        let chargeDesc = '';
                        if (index === 0) {
                            chargeDesc = solutions.length > 1 
                                ? `Fastest - ${solution.timeOfFlight}s flight time`
                                : 'Optimal solution';
                        } else {
                            const timeDiff = solution.timeOfFlight - solutions[0].timeOfFlight;
                            const elevDiff = solution.elevation - solutions[0].elevation;
                            const elevDegDiff = MortarCalculator.milsToDegrees(solution.elevation, input.mortarType) - MortarCalculator.milsToDegrees(solutions[0].elevation, input.mortarType);
                            const elevSign = elevDiff > 0 ? '+' : '';
                            chargeDesc = `+${timeDiff.toFixed(1)}s slower, ${elevSign}${elevDiff} mils (${elevSign}${elevDegDiff.toFixed(1)}¬∞) vs charge ${solutions[0].charge}`;
                        }
                        
                        const missionHTML = `
                            <div ${index > 0 ? 'id="altMission_' + index + '" class="alternativeMission"' : ''} style="${index > 0 ? 'display: none; ' : ''}background: ${index === 0 ? 'rgba(40, 55, 45, 0.9)' : 'rgba(35, 45, 42, 0.7)'}; padding: 15px; border-radius: 4px; margin-bottom: 10px; border: ${index === 0 ? '2px solid #6b8e23' : '1px solid #4a5a52'};">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <h3 style="margin: 0; font-size: 16px; color: ${index === 0 ? '#c8d4a0' : '#a8b898'};">
                                        ${trajectoryLabel} - Charge ${solution.charge}
                                    </h3>
                                    <span style="font-size: 12px; color: #95a585; font-style: italic;">
                                        ${chargeDesc}
                                    </span>
                                </div>
                                <div class="solution-grid">
                                    <div class="solution-item">
                                        <strong>AZIMUTH</strong>
                                        <div class="value" ${window.correctionApplied ? 'style="color: #ff6b6b"' : ''}>${solution.azimuthMils} mils</div>
                                        <div style="color: ${window.correctionApplied ? '#ff6b6b' : '#95a585'}; font-size: 12px;">(${solution.azimuth}¬∞)</div>
                                    </div>
                                    <div class="solution-item">
                                        <strong>ELEVATION</strong>
                                        <div class="value" ${window.correctionApplied ? 'style="color: #ff6b6b"' : ''}>${solution.elevation} mils</div>
                                        <div style="color: ${window.correctionApplied ? '#ff6b6b' : '#95a585'}; font-size: 12px;">(${solution.elevationDegrees}¬∞)</div>
                                        ${solution.elevationCorrection && solution.elevationCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">dElev: ${solution.dElev} and Elevation Correction: ${solution.elevationCorrection > 0 ? '+' : ''}${solution.elevationCorrection.toFixed(1)} mils</div>` : ''}
                                    </div>
                                    <div class="solution-item">
                                        <strong>CHARGE</strong>
                                        <div class="value" ${typeof previousChargeForDisplay === 'number' && previousChargeForDisplay !== solution.charge ? 'style="color: #ff6b6b"' : ''}>${solution.charge}</div>
                                        ${typeof previousChargeForDisplay === 'number' && previousChargeForDisplay !== solution.charge ? `<div style="color: #ff6b6b; font-size: 11px; margin-top: 2px;">was: ${previousChargeForDisplay}</div>` : ''}
                                    </div>
                                    <div class="solution-item">
                                        <strong>TIME OF FLIGHT</strong>
                                        <div class="value">${solution.timeOfFlight}s</div>
                                        ${solution.tofCorrection && solution.tofCorrection !== 0 ? `<div style="color: #95a585; font-size: 11px; margin-top: 2px;">Correction: ${solution.tofCorrection > 0 ? '+' : ''}${solution.tofCorrection.toFixed(1)}s (TOF/100m: ${solution.tofPer100m})</div>` : ''}
                                    </div>
                                </div>
                                <div style="margin-top: 10px; padding: 8px; background: rgba(20, 25, 22, 0.6); border-radius: 3px; font-size: 12px; color: #a8b898;">
                                    <strong>Charge Range:</strong> ${solution.minRange}m - ${solution.maxRange}m
                                </div>
                                <button onclick="selectMission(${solution.charge})" id="selectBtn_${solution.charge}" style="width: 100%; margin-top: 10px; padding: 8px; background: ${index === 0 ? 'linear-gradient(180deg, #6b8e23 0%, #5a7a1c 100%)' : 'linear-gradient(180deg, #555 0%, #444 100%)'}; border: 1px solid ${index === 0 ? '#8fbc1e' : '#666'}; border-radius: 4px; color: white; font-weight: 600; cursor: pointer; font-size: 13px; transition: transform 0.1s ease, box-shadow 0.1s ease;" onmousedown="this.style.transform='scale(0.95)'; this.style.boxShadow='0 0 20px rgba(143, 188, 30, 0.8)';" onmouseup="this.style.transform='scale(1)'; this.style.boxShadow='none';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                    ${index === 0 ? '‚úì Selected Mission' : 'Use This Mission'}
                                </button>
                            </div>
                        `;
                        
                        if (index === 0) {
                            optimalMissionHTML = missionHTML;
                        } else {
                            alternativeMissionsHTML += missionHTML;
                        }
                    });
                    
                    output.innerHTML = `
                        <h2>‚úÖ Firing Mission${solutions.length > 1 ? 's' : ''} Found</h2>
                        
                        <div style="background: rgba(60, 75, 50, 0.4); padding: 12px; border-radius: 4px; border: 1px solid #6b8e23; margin-bottom: 15px; color: #d8e4b0;">
                            <strong>üìê Mil System:</strong> ${MortarCalculator.getMilSystemName(input.mortarType)} &nbsp;|&nbsp; 
                            <strong style="${window.correctionApplied ? 'color: #ff6b6b;' : ''}">üìè Range:</strong> <span style="${window.correctionApplied ? 'color: #ff6b6b;' : ''}">${input.distance.toFixed(1)}m</span> &nbsp;|&nbsp; 
                            <strong>‚õ∞Ô∏è Alt Diff:</strong> ${input.heightDifference > 0 ? '+' : ''}${input.heightDifference.toFixed(1)}m
                        </div>
                        
                        ${solutions.length > 1 ? '<div style="background: rgba(60, 75, 50, 0.4); padding: 12px; border-radius: 4px; border: 1px solid #6b8e23; margin-bottom: 15px; color: #d8e4b0;"><strong>üí° Multiple Charge Options Available:</strong><br><small>Lower charges are more accurate but have limited range. Higher charges reach further but are less precise. High angle trajectories can clear obstacles.</small></div>' : ''}
                        
                        <h3 style="font-size: 16px; margin-bottom: 10px;">Fire Missions (${solutions.length}): <span style="font-size: 16px; color: #ffffff; font-weight: normal;"></span></h3>
                        
                        ${optimalMissionHTML}
                        
                        <!-- Inline Fire Correction Widget -->
                        <div id="fireCorrectionWidget" style="display: none; background: rgba(40, 55, 45, 0.9); padding: 15px; border-radius: 4px; margin-bottom: 10px; border: 2px solid #6b8e23;">
                            <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #c8d4a0;">üîÑ Adjust Fire <span id="selectedChargeDisplay" style="color: #8fbc1e;">(Charge ${solutions[0].charge})</span></h3>
                            <div>
                                <div style="color: #95a585; font-size: 12px; margin-bottom: 12px;">
                                    Observer corrections: Left/Right shifts azimuth. Add/Drop changes range.
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                                    <div>
                                        <label style="display: block; color: #a8b898; font-size: 13px; margin-bottom: 5px; font-weight: 600;">Left/Right (meters)</label>
                                        <input type="number" id="correctionLR" placeholder="0" step="1" value="0" style="width: 100%; padding: 8px; background: rgba(20, 25, 22, 0.8); border: 1px solid #4a5a52; border-radius: 3px; color: #c8d4a0; font-size: 13px;">
                                        <small style="color: #7a8a7a; display: block; margin-top: 3px; font-size: 11px;">Right: +, Left: ‚àí</small>
                                    </div>
                                    <div>
                                        <label style="display: block; color: #a8b898; font-size: 13px; margin-bottom: 5px; font-weight: 600;">Add/Drop (meters)</label>
                                        <input type="number" id="correctionAD" placeholder="0" step="1" value="0" style="width: 100%; padding: 8px; background: rgba(20, 25, 22, 0.8); border: 1px solid #4a5a52; border-radius: 3px; color: #c8d4a0; font-size: 13px;">
                                        <small style="color: #7a8a7a; display: block; margin-top: 3px; font-size: 11px;">Add: +, Drop: ‚àí</small>
                                    </div>
                                </div>
                                <button id="applyCorrection" onclick="const btn = this; btn.style.background = 'linear-gradient(180deg, #8fbc1e 0%, #7aaa18 100%)'; btn.style.transform = 'scale(0.95)'; btn.style.boxShadow = '0 0 20px rgba(143, 188, 30, 0.8)'; btn.textContent = '‚è≥ Applying...'; btn.disabled = true; setTimeout(() => { applyFireCorrectionUI(); }, 150);" style="width: 100%; padding: 10px; margin-top: 5px; background: linear-gradient(180deg, #6b8e23 0%, #5a7a1c 100%); border: 1px solid #8fbc1e; border-radius: 4px; color: white; font-weight: 600; cursor: pointer; font-size: 13px; transition: all 0.15s ease;">
                                    Apply Fire Correction
                                </button>
                            </div>
                        </div>
                        
                        ${solutions.length > 1 ? `
                        <button onclick="toggleAlternativeMissions()" id="toggleAltBtn" style="width: 100%; padding: 10px; margin-top: 20px; background: linear-gradient(180deg, #555 0%, #444 100%); border: 1px solid #666; border-radius: 4px; color: #c8d4a0; font-weight: 600; cursor: pointer; font-size: 13px; transition: transform 0.1s ease, box-shadow 0.1s ease;" onmousedown="this.style.transform='scale(0.95)'; this.style.boxShadow='0 0 20px rgba(200, 212, 160, 0.5)';" onmouseup="this.style.transform='scale(1)'; this.style.boxShadow='none';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                            ‚ñº Show ${solutions.length - 1} Alternative Mission${solutions.length > 2 ? 's' : ''}
                        </button>
                        ` : ''}
                        
                        ${alternativeMissionsHTML}
                    `;
                    
                    // Clear previous charge after output is complete
                    window.previousCharge = null;
                    
                    // Store original optimal charge for marking
                    window.originalOptimalCharge = solutions[0].charge;
                    
                    // Initialize selected charge to optimal (first) solution and show correction widget
                    window.selectedCharge = solutions[0].charge;
                    
                    // Auto-select optimal mission to show correction widget immediately
                    setTimeout(() => {
                        selectMission(solutions[0].charge);
                    }, 50);
                } else {
                    const solution = solutions[0];
                    output.classList.add('error');
                    output.innerHTML = `
                        <h2>‚ùå Target Out of Range</h2>
                        <p><strong>Error:</strong> ${solution.error}</p>
                        ${solution.minRange && solution.maxRange ? `
                            <p>
                                <strong>Valid range for this configuration:</strong><br>
                                ${solution.minRange}m - ${solution.maxRange}m
                            </p>
                        ` : ''}
                        <p style="margin-top: 15px;">
                            <strong>Suggestions:</strong>
                        </p>
                        <ul>
                            <li>Try a different mortar type or shell type</li>
                            <li>Move mortar or target positions closer/further</li>
                        </ul>
                    `;
                }
            } catch (error) {
                output.className = 'result active error';
                output.innerHTML = `
                    <h2>‚ùå Calculation Error</h2>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Check your input values and try again.</p>
                `;
                console.error('Calculation error:', error);
            }
        }
        
        // Initialize on page load
        init();
    </script>
</body>
</html>
