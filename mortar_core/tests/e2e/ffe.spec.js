import { test, expect } from '@playwright/test';
import { CalculatorPage } from './pages/CalculatorPage.js';
import { VALID_COORDS, FFE_PATTERNS } from './fixtures/test-data.js';

test.describe('Fire for Effect', () => {
  let page;
  let calcPage;

   test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();
    calcPage = new CalculatorPage(page);
    await calcPage.goto();
    
    // Perform initial calculation with valid coordinates
    const coords = VALID_COORDS.mortar_short;
    await calcPage.enterGridCoords(coords.gun, coords.target);
    await calcPage.calculate();
    await calcPage.waitForResult('success', 10000);
  });

  test.afterEach(async () => {
    await page.close();
  });

  // Setup tests
  test('should display FFE container after calculation', async () => {
    const ffeContainer = page.locator('#ffeContainer');
    await expect(ffeContainer).toBeVisible();
  });

  test('should show FFE widget when checkbox enabled', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
  });

  test('should hide FFE widget when checkbox disabled', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    
    // Enable first
    await ffeCheckbox.check();
    let ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    // Then disable
    await ffeCheckbox.uncheck();
    await expect(ffeWidget).toBeHidden();
  });

  // Pattern tests
  test('should generate lateral sheaf pattern', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    // Wait for FFE widget to become visible
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('perpendicular');
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    // Wait for FFE generation to complete - look for the output to change
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify output contains multiple round sections (FFE generates "Round X of Y" headers)
    const outputText = await page.locator('#output').innerText();
    expect(outputText).toContain('Fire for Effect');
    expect(outputText).toContain('Round 1 of');
    
    // Verify multiple rounds are generated by checking for at least 2 round headers
    const roundMatches = outputText.match(/Round \d+ of/g);
    expect(roundMatches).toBeTruthy();
    expect(roundMatches.length).toBeGreaterThan(1);
  });

  test('should generate linear sheaf pattern', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    // Wait for FFE widget to become visible
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('along-bearing');
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    // Wait for FFE generation to complete
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify FFE output is visible with linear sheaf pattern
    const outputText = await page.locator('#output').innerText();
    expect(outputText).toContain('Fire for Effect');
    expect(outputText).toContain('Linear Sheaf');
    expect(outputText).toContain('Round 1 of');
  });

  test('should generate circular pattern', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    // Wait for FFE widget to become visible
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('circular');
    
    // Verify radius input is shown
    const radiusGroup = page.locator('#ffeRadiusGroup');
    await expect(radiusGroup).toBeVisible();
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    // Wait for FFE generation to complete
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify FFE output is visible with circular pattern
    const outputText = await page.locator('#output').innerText();
    expect(outputText).toContain('Fire for Effect');
    expect(outputText).toContain('Circular Pattern');
    expect(outputText).toContain('Round 1 of');
  });

  // Configuration tests
  test('should allow selecting number of rounds (3-12)', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const roundsDropdown = page.locator('#ffeRounds');
    
    // Test selecting different values
    await roundsDropdown.selectOption('5');
    await expect(roundsDropdown).toHaveValue('5');
    
    await roundsDropdown.selectOption('10');
    await expect(roundsDropdown).toHaveValue('10');
  });

  test('should allow configuring spacing for linear patterns', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('along-bearing');
    
    const spacingInput = page.locator('#ffeSpacing');
    await spacingInput.fill('50');
    await expect(spacingInput).toHaveValue('50');
  });

  test('should show radius input only for circular pattern', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const radiusGroup = page.locator('#ffeRadiusGroup');
    const patternSelect = page.locator('#ffePattern');
    
    // Not visible for perpendicular
    await patternSelect.selectOption('perpendicular');
    await expect(radiusGroup).toBeHidden();
    
    // Not visible for along-bearing
    await patternSelect.selectOption('along-bearing');
    await expect(radiusGroup).toBeHidden();
    
    // Visible for circular
    await patternSelect.selectOption('circular');
    await expect(radiusGroup).toBeVisible();
  });

  test('should allow configuring radius for circular pattern', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('circular');
    
    const radiusInput = page.locator('#ffeRadius');
    await radiusInput.fill('100');
    await expect(radiusInput).toHaveValue('100');
  });

  // Result tests
  test('should display multiple firing solutions for FFE', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    // Wait for FFE widget to become visible
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    const patternSelect = page.locator('#ffePattern');
    await patternSelect.selectOption('perpendicular');
    
    const roundsDropdown = page.locator('#ffeRounds');
    await roundsDropdown.selectOption('5');
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    // Wait for FFE generation to complete
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify 5 rounds are requested (some may be out of range)
    const outputText = await page.locator('#output').innerText();
    expect(outputText).toContain('Fire for Effect');
    
    // Check that rounds are generated - the output shows "X of 5 rounds"
    expect(outputText).toMatch(/\d+ of 5 rounds/);
    
    // Verify at least one round is displayed
    expect(outputText).toContain('Round 1 of');
  });

  test('should show "Show Base Solution" button after FFE generated', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    const showBaseBtn = page.locator('#showBaseSolution');
    await expect(showBaseBtn).toBeVisible();
  });

  test('should return to base solution when button clicked', async () => {
    const ffeCheckbox = page.locator('#ffeEnabled');
    await ffeCheckbox.check();
    
    // Wait for FFE widget to become visible
    const ffeWidget = page.locator('#ffeWidget');
    await expect(ffeWidget).toBeVisible();
    
    const roundsDropdown = page.locator('#ffeRounds');
    await roundsDropdown.selectOption('5');
    
    const generateBtn = page.locator('#generateFFE');
    await generateBtn.click();
    
    // Wait for FFE generation to complete
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify FFE output is visible initially
    let outputText = await page.locator('#output').innerText();
    expect(outputText).toContain('Fire for Effect');
    expect(outputText).toContain('Round 1 of');
    
    // Click show base solution button
    const showBaseBtn = page.locator('#showBaseSolution');
    await showBaseBtn.click();
    
    // Wait for base solution to be restored
    await page.waitForFunction(() => {
      const output = document.querySelector('#output');
      return output && !output.innerText.includes('Fire for Effect');
    }, { timeout: 5000 }).catch(() => null);
    
    // Verify base solution is shown (no FFE pattern, just single solution)
    outputText = await page.locator('#output').innerText();
    expect(outputText).not.toContain('Fire for Effect');
    // Base solution should have azimuth/elevation but not "Round X of Y"
    expect(outputText).not.toContain('Round 1 of');
  });
});
