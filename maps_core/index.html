<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Arma Map Viewer (engine + coords)</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

    <!-- Favicon (avoid 404 spam) -->
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: calc(100% - 40px);
            overflow: hidden;
            background: #222;
        }

        .leaflet-container {
            background: #222 !important;
        }

        #toolbar {
            height: 40px;
            padding: 4px 8px;
            background: #222;
            color: #eee;
            font-family: system-ui, sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #coords {
            margin-left: auto;
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <label for="mapSelect">Map</label>
        <select id="mapSelect"></select>
        <button id="resetBtn" title="Reset view to initial position and zoom">Reset View</button>
        <div id="coords">Move mouse over mapâ€¦</div>
    </div>
    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- jQuery (required by engine, even in data-only mode) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <!-- Minimal Engine (namespaces, convertCoordinates, height.get) -->
    <script src="mapEngine.js"></script>

    <!-- Map viewer wrapper -->
    <script>
        // nsName: "everon", layerName: "satellite" / "scheme"
        function initNamespace(nsName, layerName) {
            const ns = engine.namespaces[nsName][layerName];
            // Keep a richer copy for convenience
            engine.namespace = { name: nsName, layer: layerName, ...ns };
            // IMPORTANT: engine.convertCoordinates / unconvertCoordinates use engine.data
            engine.data = ns;
        }

        function buildBoundsFromCorner(ns) {
            const c = ns.corner(ns.size[0], ns.size[1]);
            return L.latLngBounds(c[2], c[3]);
        }

        function makeTileLayer(cfg) {
            const ext = cfg.webp ? 'webp' : 'png';
            return L.tileLayer(
                `tiles/${cfg.dir}/{z}/{x}/{y}.${ext}`,
                {
                    bounds: buildBoundsFromCorner(cfg),
                    maxZoom: cfg.zoom.max,
                    minZoom: cfg.zoom.min,
                    noWrap: true,
                    unloadInvisibleTiles: true,
                    reuseTiles: true,
                    tileLoadRetryTime: 150,
                    tileSize: cfg.tileSize || 256
                }
            );
        }

        function init() {
            const mapSelect = document.getElementById('mapSelect');
            const coordsLabel = document.getElementById('coords');

            // Build dropdown entries from engine.namespaces
            const entries = [];
            Object.keys(engine.namespaces).forEach(nsName => {
                const ns = engine.namespaces[nsName];
                if (ns.satellite) {
                    entries.push({ key: nsName, layer: 'satellite', cfg: ns.satellite });
                } else if (ns.scheme) {
                    entries.push({ key: nsName, layer: 'scheme', cfg: ns.scheme });
                }
            });

            entries.forEach((e, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = `${e.cfg.name} (${e.layer})`;
                mapSelect.appendChild(opt);
            });

            // Initial namespace (Everon satellite by default)
            initNamespace(engine.namespace_default || 'everon', 'satellite');
            
            // Load height map data for initial map
            engine.height.load();
            
            const ns = engine.namespace;
            const bounds = buildBoundsFromCorner(ns);

            const map = L.map('map', {
                crs: ns.CRS,
                zoomControl: true,
                zoomSnap: 1.75,
                zoomDelta: 2,
                wheelPxPerZoomLevel: 100,
                maxBounds: bounds
            });

            map.setView(L.latLng(ns.center_pos[1], ns.center_pos[0]), ns.zoom.start);
            map.setMinZoom(ns.zoom.min);
            map.setMaxZoom(ns.zoom.max);

            let baseLayer = makeTileLayer(ns);
            baseLayer.addTo(map);

            // Mousemove â†’ display game coordinates (x, y, z)
            map.on('mousemove', ev => {
                const lng = ev.latlng.lng;
                const lat = ev.latlng.lat;

                if (!engine.data || !engine.data.mod || !engine.data.mod.lng || !engine.data.mod.lat) {
                    return;
                }

                let grid;
                try {
                    // Map (Leaflet CRS) â†’ game/grid coords, with engineâ€™s corrections
                    grid = engine.convertCoordinates(lng, lat, true, true);
                } catch (err) {
                    console.warn('[viewer] convertCoordinates failed', err, engine.data);
                    return;
                }

                if (!Array.isArray(grid) || grid.length < 2) return;

                const x = parseInt(grid[0], 10);
                const y = parseInt(grid[1], 10);

                let z = null;
                // Only try to get height if height map is loaded and available
                if (engine.namespace.height && engine.height.map && engine.height.size) {
                    try {
                        z = parseInt(engine.height.get(x, y), 10);
                    } catch (err) {
                        z = null;
                    }
                }

                const text = z != null ? `(${x}, ${y}, ${z}m)` : `(${x}, ${y})`;
                coordsLabel.textContent = text;
            });

            // Click â†’ copy coordinates to clipboard
            map.on('click', ev => {
                const lng = ev.latlng.lng;
                const lat = ev.latlng.lat;

                if (!engine.data || !engine.data.mod || !engine.data.mod.lng || !engine.data.mod.lat) {
                    return;
                }

                let grid;
                try {
                    grid = engine.convertCoordinates(lng, lat, true, true);
                } catch (err) {
                    console.warn('[viewer] convertCoordinates failed for click', err);
                    return;
                }

                if (!Array.isArray(grid) || grid.length < 2) return;

                const x = parseInt(grid[0], 10);
                const y = parseInt(grid[1], 10);
                
                // Get height if available
                let z = null;
                if (engine.namespace.height && engine.height.map && engine.height.size) {
                    try {
                        z = parseInt(engine.height.get(x, y), 10);
                    } catch (err) {
                        z = null;
                    }
                }
                
                const coordText = z != null ? `${x}, ${y}, ${z}` : `${x}, ${y}`;

                // Copy to clipboard
                navigator.clipboard.writeText(coordText).then(() => {
                    const originalText = coordsLabel.textContent;
                    coordsLabel.textContent = `ðŸ“‹ Copied: ${coordText}`;
                    setTimeout(() => {
                        coordsLabel.textContent = originalText;
                    }, 1500);
                }).catch(err => {
                    console.error('[viewer] Clipboard copy failed:', err);
                    coordsLabel.textContent = `âŒ Copy failed`;
                    setTimeout(() => {
                        coordsLabel.textContent = coordText;
                    }, 1500);
                });
            });

            // Reset button â†’ return to initial view
            document.getElementById('resetBtn').addEventListener('click', () => {
                const cfg = engine.namespace;
                map.setView(L.latLng(cfg.center_pos[1], cfg.center_pos[0]), cfg.zoom.start);
            });

            // Map switcher
            mapSelect.addEventListener('change', () => {
                const e = entries[mapSelect.value];
                initNamespace(e.key, e.layer);
                const cfg = engine.namespace;

                // Load height map data for new map
                engine.height.load();

                const cornerBounds = cfg.corner(cfg.size[0], cfg.size[1]);
                
                // Set maxBounds to match tile layer bounds exactly (inner bounds)
                map.setMaxBounds(L.latLngBounds(cornerBounds[2], cornerBounds[3]));
                map.setMinZoom(cfg.zoom.min);
                map.setMaxZoom(cfg.zoom.max);
                map.setView(L.latLng(cfg.center_pos[1], cfg.center_pos[0]), cfg.zoom.start);

                if (baseLayer) map.removeLayer(baseLayer);
                baseLayer = makeTileLayer(cfg);
                baseLayer.addTo(map);

                coordsLabel.textContent = 'Move mouse over mapâ€¦';
            });

            window.map = map;
            console.log('[viewer] Initialized in data-only mode');
            console.log('[viewer] Available maps:', Object.keys(engine.namespaces));
            console.log('[viewer] Current namespace:', engine.namespace.name);
        }

        // Wait for all scripts to be ready, then init
        $(window).on('load', function () {
            const check = setInterval(() => {
                if (typeof L !== 'undefined' &&
                    typeof engine !== 'undefined' &&
                    engine.namespaces &&
                    Object.keys(engine.namespaces).length > 0) {
                    clearInterval(check);
                    init();
                }
            }, 50);
        });
    </script>
</body>

</html>